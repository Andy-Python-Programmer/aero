From ea350e347faaa97e0499d34582ff068510809542 Mon Sep 17 00:00:00 2001
From: Anhad Singh <andypythonappdeveloper@gmail.com>
Date: Fri, 13 Oct 2023 22:50:34 +1100
Subject: [PATCH] <xxx>

Signed-off-by: Anhad Singh <andypythonappdeveloper@gmail.com>
---
 options/glibc/generic/execinfo.cpp     |  5 +++--
 options/posix/generic/posix_stdlib.cpp |  2 +-
 options/rtdl/generic/linker.cpp        |  2 +-
 sysdeps/aero/generic/aero.cpp          |  9 ++++++---
 sysdeps/aero/generic/filesystem.cpp    | 10 ++++++++++
 sysdeps/aero/generic/signals.cpp       | 19 +++++++------------
 sysdeps/aero/generic/sockets.cpp       | 16 ++++++++++++++++
 sysdeps/aero/include/aero/syscall.h    |  2 ++
 8 files changed, 46 insertions(+), 19 deletions(-)

diff --git a/options/glibc/generic/execinfo.cpp b/options/glibc/generic/execinfo.cpp
index 3474615..aaf593a 100644
--- a/options/glibc/generic/execinfo.cpp
+++ b/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,10 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/charset.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "backtrace: Not implemented" << frg::endlog;
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git a/options/posix/generic/posix_stdlib.cpp b/options/posix/generic/posix_stdlib.cpp
index 76b85dc..4b783b3 100644
--- a/options/posix/generic/posix_stdlib.cpp
+++ b/options/posix/generic/posix_stdlib.cpp
@@ -464,7 +464,7 @@ int grantpt(int) {
 }
 
 double strtod_l(const char *__restrict__ nptr, char ** __restrict__ endptr, locale_t) {
-	mlibc::infoLogger() << "mlibc: strtod_l ignores locale!" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: strtod_l ignores locale!" << frg::endlog;
 	return strtod(nptr, endptr);
 }
 
diff --git a/options/rtdl/generic/linker.cpp b/options/rtdl/generic/linker.cpp
index c604a50..eec0b7b 100644
--- a/options/rtdl/generic/linker.cpp
+++ b/options/rtdl/generic/linker.cpp
@@ -18,7 +18,7 @@ uintptr_t libraryBase = 0x41000000;
 
 constexpr bool verbose = false;
 constexpr bool stillSlightlyVerbose = false;
-constexpr bool logBaseAddresses = false;
+constexpr bool logBaseAddresses = true;
 constexpr bool logRpath = false;
 constexpr bool eagerBinding = true;
 
diff --git a/sysdeps/aero/generic/aero.cpp b/sysdeps/aero/generic/aero.cpp
index e6bd277..a341fcf 100644
--- a/sysdeps/aero/generic/aero.cpp
+++ b/sysdeps/aero/generic/aero.cpp
@@ -303,10 +303,13 @@ int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
     return 0;
 }
 
-void sys_thread_exit() UNIMPLEMENTED("sys_thread_exit")
+void sys_thread_exit() {
+    syscall(SYS_EXIT);
+	__builtin_trap();
+}
 
-    int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru,
-                    pid_t *ret_pid) {
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru,
+                pid_t *ret_pid) {
     if (ru) {
         mlibc::infoLogger()
             << "mlibc: struct rusage in sys_waitpid is unsupported"
diff --git a/sysdeps/aero/generic/filesystem.cpp b/sysdeps/aero/generic/filesystem.cpp
index fa5a369..33a11f4 100644
--- a/sysdeps/aero/generic/filesystem.cpp
+++ b/sysdeps/aero/generic/filesystem.cpp
@@ -39,6 +39,16 @@ int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
     return 0;
 }
 
+int sys_fsync(int) {
+	mlibc::infoLogger() << "\e[35mmlibc: fsync is a stub\e[39m" << frg::endlog;
+	return 0;
+}
+
+int sys_fdatasync(int) {
+	mlibc::infoLogger() << "\e[35mmlibc: fdatasync() is a no-op\e[39m" << frg::endlog;
+	return 0;
+}
+
 // clang-format off
 int sys_pwrite(int fd, const void *buffer, size_t count, off_t off,
                ssize_t *written) UNIMPLEMENTED("sys_pwrite") 
diff --git a/sysdeps/aero/generic/signals.cpp b/sysdeps/aero/generic/signals.cpp
index a6f69ff..611db69 100644
--- a/sysdeps/aero/generic/signals.cpp
+++ b/sysdeps/aero/generic/signals.cpp
@@ -29,25 +29,20 @@ int sys_sigaction(int how, const struct sigaction *__restrict action,
 #endif
 
     auto sigreturn = (sc_word_t)__mlibc_signal_restore;
-
-    auto res = syscall(SYS_SIGACTION, how, (sc_word_t)action, sigreturn,
+    auto ret = syscall(SYS_SIGACTION, how, (sc_word_t)action, sigreturn,
                        (sc_word_t)old_action);
 
-    if (res < 0) {
-        return -res;
-    }
-
+    if(int e = sc_error(ret); e)
+        return e;
     return 0;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set,
                     sigset_t *__restrict retrieve) {
-    auto result = syscall(SYS_SIGPROCMASK, how, set, retrieve);
 
-    if (result < 0) {
-        return -result;
-    }
-
-    return 0;
+    auto ret = syscall(SYS_SIGPROCMASK, how, set, retrieve);
+    if(int e = sc_error(ret); e)
+		return e;
+	return 0;
 }
 } // namespace mlibc
\ No newline at end of file
diff --git a/sysdeps/aero/generic/sockets.cpp b/sysdeps/aero/generic/sockets.cpp
index 0cce3c0..10af36a 100644
--- a/sysdeps/aero/generic/sockets.cpp
+++ b/sysdeps/aero/generic/sockets.cpp
@@ -221,6 +221,22 @@ int sys_setsockopt(int fd, int layer, int number, const void *buffer,
     }
 }
 
+int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+	auto ret = syscall(SYS_GETPEERNAME, fd, addr_ptr, &max_addr_length);
+	if (int e = sc_error(ret); e)
+		return e;
+	*actual_length = max_addr_length;
+	return 0;
+}
+
+int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+	auto ret = syscall(SYS_GETSOCKNAME, fd, addr_ptr, &max_addr_length);
+	if (int e = sc_error(ret); e)
+		return e;
+	*actual_length = max_addr_length;
+	return 0;
+}
+
 int sys_shutdown(int sockfd, int how) {
     auto ret = syscall(SYS_SOCK_SHUTDOWN, sockfd, how);
     if(int e = sc_error(ret); e)
diff --git a/sysdeps/aero/include/aero/syscall.h b/sysdeps/aero/include/aero/syscall.h
index 3f36e4d..39c5b65 100644
--- a/sysdeps/aero/include/aero/syscall.h
+++ b/sysdeps/aero/include/aero/syscall.h
@@ -80,6 +80,8 @@
 #define SYS_SETSID 73
 #define SYS_GETPGID 74
 #define SYS_SOCK_SHUTDOWN 75
+#define SYS_GETPEERNAME 76
+#define SYS_GETSOCKNAME 77
 
 // Invalid syscall used to trigger a log error in the kernel (as a hint)
 // so, that we can implement the syscall in the kernel.
-- 
2.42.0

