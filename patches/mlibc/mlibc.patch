From d3bcf4e954ce27b14f5ffdb994486c984d1773ad Mon Sep 17 00:00:00 2001
From: Matt Taylor <mstaveleytaylor@gmail.com>
Date: Fri, 17 Jun 2022 15:28:34 +0100
Subject: [PATCH] abi-bits: add domainname to utsname

---
 ABI_BREAKS.md                         |   1 +
 abis/linux/utsname.h                  |   1 +
 options/ansi/generic/stdlib-stubs.cpp | 100 ++++++++++++++++++++++----
 options/glibc/generic/execinfo.cpp    |   6 +-
 options/rtdl/generic/linker.cpp       |   2 +-
 sysdeps/aero/generic/aero.cpp         |  10 ++-
 sysdeps/aero/include/aero/syscall.h   |   1 +
 7 files changed, 104 insertions(+), 17 deletions(-)

diff --git a/ABI_BREAKS.md b/ABI_BREAKS.md
index 0cd3993b..d2a0bb7d 100644
--- a/ABI_BREAKS.md
+++ b/ABI_BREAKS.md
@@ -6,3 +6,4 @@ This document lists the ABI breaks that were made in each mlibc major version.
 
 - [#452](https://github.com/managarm/mlibc/pull/452): The functions `FD_{CLR,ISSET,SET,ZERO}` were renamed to `__FD_{CLR,ISSET,SET,ZERO}` and replaced by macros to match Wine's assumptions.
 - [#511](https://github.com/managarm/mlibc/pull/511): Musl's regex engine was added, implementing `regcomp` and `regexec`. This required some changes to the `regex_t` struct.
+- [#504](https://github.com/managarm/mlibc/pull/504): A `domainname` member was added to `struct utsname`, which is a glibc extension.
diff --git a/abis/linux/utsname.h b/abis/linux/utsname.h
index 2cd22265..9875a46e 100644
--- a/abis/linux/utsname.h
+++ b/abis/linux/utsname.h
@@ -7,6 +7,7 @@ struct utsname {
 	char release[65];
 	char version[65];
 	char machine[65];
+	char domainname[65];
 };
 
 #endif // _ABIBITS_UTSNAME_T_H
diff --git a/options/ansi/generic/stdlib-stubs.cpp b/options/ansi/generic/stdlib-stubs.cpp
index 375d4d72..2b4934d9 100644
--- a/options/ansi/generic/stdlib-stubs.cpp
+++ b/options/ansi/generic/stdlib-stubs.cpp
@@ -374,18 +374,94 @@ int mblen(const char *mbs, size_t mb_limit) {
 	return nseq.it - mbs;
 }
 
-int mbtowc(wchar_t *__restrict wc, const char *__restrict mbs, size_t max_size) {
-	mlibc::infoLogger() << "mlibc: Broken mbtowc() called" << frg::endlog;
-	__ensure(max_size);
-
-	if(wc && mbs){
-		if(*mbs){
-			*wc = *mbs;
-		} else {
-			return 0; // When mbs is a null byte, return 0
-		}
-	}
-	return 1;
+// Upper 6 state bits are a negative integer offset to bound-check next byte
+//    equivalent to: ( (b-0x80) | (b+offset) ) & ~0x3f
+#define OOB(c, b) (((((b) >> 3) - 0x10) | (((b) >> 3) + ((int32_t)(c) >> 26))) & ~7)
+
+// Interval [a,b). Either a must be 80 or b must be c0, lower 3 bits clear.
+#define R(a, b) ((uint32_t)((a == 0x80 ? 0x40u - b : 0u - a) << 23))
+#define FAILSTATE R(0x80, 0x80)
+
+#define SA 0xc2u
+#define SB 0xf4u
+
+// Arbitrary encoding for representing code units instead of characters.
+#define CODEUNIT(c) (0xdfff & (signed char)(c))
+#define IS_CODEUNIT(c) ((unsigned)(c)-0xdf80 < 0x80)
+
+#define C(x) ( x<2 ? -1 : ( R(0x80,0xc0) | x ) )
+#define D(x) C((x+16))
+#define E(x) ( ( x==0 ? R(0xa0,0xc0) : \
+                 x==0xd ? R(0x80,0xa0) : \
+                 R(0x80,0xc0) ) \
+             | ( R(0x80,0xc0) >> 6 ) \
+             | x )
+#define F(x) ( ( x>=5 ? 0 : \
+                 x==0 ? R(0x90,0xc0) : \
+                 x==4 ? R(0x80,0xa0) : \
+                 R(0x80,0xc0) ) \
+             | ( R(0x80,0xc0) >> 6 ) \
+             | ( R(0x80,0xc0) >> 12 ) \
+             | x )
+
+const uint32_t bittab[] = {
+	C(0x2),C(0x3),C(0x4),C(0x5),C(0x6),C(0x7),
+	C(0x8),C(0x9),C(0xa),C(0xb),C(0xc),C(0xd),C(0xe),C(0xf),
+	D(0x0),D(0x1),D(0x2),D(0x3),D(0x4),D(0x5),D(0x6),D(0x7),
+	D(0x8),D(0x9),D(0xa),D(0xb),D(0xc),D(0xd),D(0xe),D(0xf),
+	E(0x0),E(0x1),E(0x2),E(0x3),E(0x4),E(0x5),E(0x6),E(0x7),
+	E(0x8),E(0x9),E(0xa),E(0xb),E(0xc),E(0xd),E(0xe),E(0xf),
+	F(0x0),F(0x1),F(0x2),F(0x3),F(0x4)
+};
+
+// Converts a multibyte sequence to a wide character.
+//
+// Credits - MUSL
+int mbtowc(wchar_t *__restrict wc, const char *__restrict src, size_t n) {
+	unsigned c;
+	const unsigned char *s = static_cast<const unsigned char *>((const void *)src);
+	wchar_t dummy;
+
+  	if (!s) return 0;
+  	if (!n) goto ilseq;
+  	if (!wc) wc = &dummy;
+
+  	if (*s < 0x80) return !!(*wc = *s);
+	if (MB_CUR_MAX == 1) return (*wc = CODEUNIT(*s)), 1;
+  	if (*s - SA > SB - SA) goto ilseq;
+  	
+	c = bittab[*s++ - SA];
+
+  	// Avoid excessive checks against n: If shifting the state n-1
+	// times does not clear the high bit, then the value of n is
+	// insufficient to read a character.
+  	if (n < 4 && ((c << (6 * n - 6)) & (1U << 31))) goto ilseq;
+  	if (OOB(c, *s)) goto ilseq;
+  	
+	c = c << 6 | (*s++ - 0x80);
+  	
+	if (!(c & (1U << 31))) {
+    	*wc = c;
+    	return 2;
+  	}
+
+  	if (*s - 0x80u >= 0x40) goto ilseq;
+  	
+	c = c << 6 | (*s++ - 0x80);
+  	
+	if (!(c & (1U << 31))) {
+    	*wc = c;
+    	return 3;
+  	}
+
+  	if (*s - 0x80u >= 0x40) goto ilseq;
+	
+	*wc = c << 6 | (*s++ - 0x80);
+	return 4;
+
+ilseq:
+	errno = EILSEQ;
+	return -1;
 }
 
 int wctomb(char *, wchar_t) {
diff --git a/options/glibc/generic/execinfo.cpp b/options/glibc/generic/execinfo.cpp
index 3474615e..c0081e30 100644
--- a/options/glibc/generic/execinfo.cpp
+++ b/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,11 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/debug.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "backtrace() is unimplemented" << frg::endlog;
+	// __ensure(!"Not implemented");
+	// __builtin_unreachable();
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git a/options/rtdl/generic/linker.cpp b/options/rtdl/generic/linker.cpp
index c2eceff6..d2d91b13 100644
--- a/options/rtdl/generic/linker.cpp
+++ b/options/rtdl/generic/linker.cpp
@@ -15,7 +15,7 @@ uintptr_t libraryBase = 0x41000000;
 
 bool verbose = false;
 bool stillSlightlyVerbose = false;
-bool logBaseAddresses = false;
+bool logBaseAddresses = true;
 bool eagerBinding = true;
 
 #if defined(__x86_64__)
diff --git a/sysdeps/aero/generic/aero.cpp b/sysdeps/aero/generic/aero.cpp
index 43ddb906..f4fe182f 100644
--- a/sysdeps/aero/generic/aero.cpp
+++ b/sysdeps/aero/generic/aero.cpp
@@ -124,7 +124,9 @@ int sys_anon_free(void *pointer, size_t size) {
 }
 
 void sys_libc_panic() {
-    sys_libc_log("libc panic!");
+    mlibc::infoLogger() << "libc_panic: panicked at 'unknown'" << frg::endlog;
+    __ensure(!syscall(SYS_BACKTRACE));
+    
     sys_exit(1);
 }
 
@@ -233,7 +235,11 @@ uid_t sys_geteuid() {
     return 0;
 }
 
-int sys_setuid(uid_t uid) UNIMPLEMENTED("sys_setuid")
+// int sys_setuid(uid_t uid) {
+//     mlibc::infoLogger() << "mlibc: sys_setuid is a stub" << frg::endlog;
+//     return 0;
+// }
+
 int sys_seteuid(uid_t euid) UNIMPLEMENTED("sys_seteuid")
 
 gid_t sys_getgid() {
diff --git a/sysdeps/aero/include/aero/syscall.h b/sysdeps/aero/include/aero/syscall.h
index 12f8dc61..cf57bd3d 100644
--- a/sysdeps/aero/include/aero/syscall.h
+++ b/sysdeps/aero/include/aero/syscall.h
@@ -64,6 +64,7 @@
 #define SYS_FUTEX_WAIT 57
 #define SYS_FUTEX_WAKE 58
 #define SYS_LINK 59
+#define SYS_BACKTRACE 60
 
 // Invalid syscall used to trigger a log error in the kernel (as a hint)
 // so, that we can implement the syscall in the kernel.
-- 
2.25.1

