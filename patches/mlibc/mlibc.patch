From ff3ad2ec971fffda2a1f098d4e574361f14ab0d2 Mon Sep 17 00:00:00 2001
From: Anhad Singh <andypythonappdeveloper@gmail.com>
Date: Tue, 14 Nov 2023 17:51:25 +1100
Subject: [PATCH] <xxx>

Signed-off-by: Anhad Singh <andypythonappdeveloper@gmail.com>
---
 options/intl/generic/libintl-stubs.cpp      |  66 ++-
 options/posix/generic/pthread-stubs.cpp     |  90 +++-
 options/rtdl/generic/linker.cpp             |   5 +-
 options/rtdl/include/mlibc/rtdl-sysdeps.hpp |   1 +
 sysdeps/aero/generic/aero.cpp               |  28 +-
 sysdeps/aero/generic/filesystem.cpp         |  32 +-
 sysdeps/aero/generic/sockets.cpp            |  10 +-
 sysdeps/aero/include/aero/syscall.h         |   3 +
 sysdeps/aero/include/mlibc/jsmn.h           | 474 ++++++++++++++++++++
 9 files changed, 632 insertions(+), 77 deletions(-)
 create mode 100644 sysdeps/aero/include/mlibc/jsmn.h

diff --git a/options/intl/generic/libintl-stubs.cpp b/options/intl/generic/libintl-stubs.cpp
index 8d4b28f..94ab421 100644
--- a/options/intl/generic/libintl-stubs.cpp
+++ b/options/intl/generic/libintl-stubs.cpp
@@ -1,73 +1,57 @@
 #include <libintl.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
 #include <bits/ensure.h>
 
+static char *current_domain;
+
 char *gettext(const char *msgid) {
-	(void)msgid;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	// (void)msgid;
+	// __ensure(!"Not implemented");
+	// __builtin_unreachable();
+	return (char*)"";
 }
 
 char *dgettext(const char *domainname, const char *msgid) {
-	(void)domainname;
-	(void)msgid;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return (char*)"";
 }
 
 char *dcgettext(const char *domainname, const char *msgid,
 		int category) {
-	(void)domainname;
-	(void)msgid;
-	(void)category;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();	
+	return (char*)"";
+
 }
 
 char *ngettext(const char *msgid, const char *msgid_plural, unsigned long int n) {
-	(void)msgid;
-	(void)msgid_plural;
-	(void)n;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();	
+	return (char*)"";
+	
 }
 
 char *dngettext(const char *domainname, const char *msgid,
 		const char *msgid_plural, unsigned long int n) {
-	(void)domainname;
-	(void)msgid;
-	(void)msgid_plural;
-	(void)n;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return (char*)"";
+
 }
 
 char *dcngettext(const char *domainname, const char *msgid,
 		const char *msgid_plural, unsigned long int n, int category) {
-	(void)domainname;
-	(void)msgid;
-	(void)msgid_plural;
-	(void)n;
-	(void)category;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return (char*)"";
+
 }
 
 char *textdomain(const char *domainname) {
-	(void)domainname;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	if(!domainname)
+		return current_domain ? current_domain : (char *)"messages";
+	
+	return (char*)"messages";
 }
 
 char *bindtextdomain(const char *domainname, const char *dirname) {
-	(void)domainname;
-	(void)dirname;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return (char*)"";
+
 }
 
 char *bind_textdomain_codeset(const char *domainname, const char *codeset) {
-	(void)domainname;
-	(void)codeset;
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return (char*)"";
 }
diff --git a/options/posix/generic/pthread-stubs.cpp b/options/posix/generic/pthread-stubs.cpp
index 5618dc6..a5edec6 100644
--- a/options/posix/generic/pthread-stubs.cpp
+++ b/options/posix/generic/pthread-stubs.cpp
@@ -1,4 +1,3 @@
-
 #include <stddef.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -265,6 +264,87 @@ int pthread_attr_setsigmask_np(pthread_attr_t *__restrict attr,
 }
 
 namespace {
+#include <mlibc/jsmn.h>
+#ifdef __aero__
+	static bool jsoneq(const char *input, jsmntok_t tok, const char *expected) {
+		if (tok.type == JSMN_STRING &&
+			(int)strlen(expected) == tok.end - tok.start &&
+			strncmp(input + tok.start, expected, tok.end - tok.start) == 0) {
+			return true;
+		}
+
+		return false;
+	}
+
+	size_t string_to_usize(const char *string, size_t length) {
+		size_t ret = 0;
+		for (size_t i = 0; i < length; i++) {
+		ret = ret * 10 + (string[i] - '0');
+		}
+
+		return ret;
+	}
+
+	void get_own_stackinfo(void **stack_addr, size_t *stack_size) {
+		auto fp = fopen("/proc/self/maps", "r");
+		if (!fp) {
+			mlibc::infoLogger() << "mlibc pthreads: /proc/self/maps does not exist! Producing incorrect"
+				" stack results!" << frg::endlog;
+			return;
+		}
+
+		auto sp = mlibc::get_sp();
+
+		char *INPUT = (char *)malloc(4096 * 4);
+		size_t INPUT_SIZE = fread(INPUT, 1, 4096 * 4, fp);
+
+		jsmn_parser parser;
+		jsmn_init(&parser);
+
+		int n = jsmn_parse(&parser, INPUT, INPUT_SIZE, nullptr, 0);
+		FRG_ASSERT(n > 0);
+
+		jsmntok_t *tokens = static_cast<jsmntok_t *>(malloc(sizeof(jsmntok_t) * n));
+
+		jsmn_init(&parser);
+		int result = jsmn_parse(&parser, INPUT, INPUT_SIZE, tokens, n);
+		FRG_ASSERT(tokens[0].type == JSMN_OBJECT);
+
+		FRG_ASSERT(jsoneq(INPUT, tokens[1], "maps"));
+
+		size_t n_fields = tokens[3].size;
+		for (size_t i = 3; i < tokens[2].size * (n_fields * 2 + 1); i+=(n_fields * 2 + 1)) {
+			jsmntok_t *mapping = &tokens[i];
+			FRG_ASSERT(mapping->type == JSMN_OBJECT);
+
+			size_t start = SIZE_MAX;
+			size_t end = SIZE_MAX;
+
+			for (size_t j = 1; j < mapping->size * 2; j += 2) {
+				jsmntok_t *value = &mapping[j + 1];
+
+				size_t val = string_to_usize(INPUT + value->start, value->end - value->start);
+
+				if (jsoneq(INPUT, mapping[j], "start")) {
+					start = val; 
+				} else if (jsoneq(INPUT, mapping[j], "end")) {
+					end = val;
+				}
+			}
+
+			if (sp < end && sp > start) {
+				*stack_addr = reinterpret_cast<void *>(start);
+				*stack_size = end - start;
+
+				fclose(fp);
+				free(INPUT);
+				return;
+			}
+		}
+
+		FRG_ASSERT(!"reached unreachable code");
+	}
+#else
 	void get_own_stackinfo(void **stack_addr, size_t *stack_size) {
 		auto fp = fopen("/proc/self/maps", "r");
 		if (!fp) {
@@ -290,7 +370,8 @@ namespace {
 
 		fclose(fp);
 	}
-}
+#endif
+} // namespace annonymous
 
 int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr) {
 	auto tcb = reinterpret_cast<Tcb*>(thread);
@@ -299,9 +380,10 @@ int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr) {
 	if (!tcb->stackAddr || !tcb->stackSize) {
 		// allocate stack
 
-		attr->__mlibc_stackaddr = 0x00;
+		attr->__mlibc_stackaddr = (void*)0x7ffffff9a000;
 		attr->__mlibc_stacksize = 0x20000;
-		// get_own_stackinfo(&attr->__mlibc_stackaddr, &attr->__mlibc_stacksize);
+
+		get_own_stackinfo(&attr->__mlibc_stackaddr, &attr->__mlibc_stacksize);
 	} else {
 		attr->__mlibc_stacksize = tcb->stackSize;
 		attr->__mlibc_stackaddr = tcb->stackAddr;
diff --git a/options/rtdl/generic/linker.cpp b/options/rtdl/generic/linker.cpp
index 50cca94..a095ab0 100644
--- a/options/rtdl/generic/linker.cpp
+++ b/options/rtdl/generic/linker.cpp
@@ -438,6 +438,7 @@ void ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
 
 	__ensure(!(object->baseAddress & (hugeSize - 1)));
 
+	size_t tagSize = highest_address - object->baseAddress;
 #if MLIBC_MMAP_ALLOCATE_DSO
 	void *mappedAddr = nullptr;
 
@@ -457,9 +458,11 @@ void ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
 	libraryBase += (highest_address + (hugeSize - 1)) & ~(hugeSize - 1);
 #endif
 
-	if(verbose || logBaseAddresses)
+	if(verbose || logBaseAddresses) {
+		mlibc::sys_tag_memory((void *)object->baseAddress, tagSize, object->name.data());
 		mlibc::infoLogger() << "rtdl: Loading " << object->name
 				<< " at " << (void *)object->baseAddress << frg::endlog;
+	}
 
 	// Load all segments.
 	constexpr size_t pageSize = 0x1000;
diff --git a/options/rtdl/include/mlibc/rtdl-sysdeps.hpp b/options/rtdl/include/mlibc/rtdl-sysdeps.hpp
index c35271c..8a941b2 100644
--- a/options/rtdl/include/mlibc/rtdl-sysdeps.hpp
+++ b/options/rtdl/include/mlibc/rtdl-sysdeps.hpp
@@ -6,6 +6,7 @@ namespace [[gnu::visibility("hidden")]] mlibc {
 int sys_tcb_set(void *pointer);
 
 [[gnu::weak]] int sys_vm_readahead(void *pointer, size_t size);
+[[gnu::weak]] int sys_tag_memory(void *ptr, size_t size, char *tag);
 
 } // namespace mlibc
 
diff --git a/sysdeps/aero/generic/aero.cpp b/sysdeps/aero/generic/aero.cpp
index e19b159..a54b6d3 100644
--- a/sysdeps/aero/generic/aero.cpp
+++ b/sysdeps/aero/generic/aero.cpp
@@ -62,6 +62,10 @@ static frg::vector<Slice, MemoryAllocator> create_slice(char *const arg[]) {
 }
 
 namespace mlibc {
+int sys_tag_memory(void *ptr, size_t size, char *tag) {
+    return syscall(SYS_DEBUG, ptr, size, tag, strlen(tag));
+}
+
 int sys_uname(struct utsname *buf) {
     auto result = syscall(SYS_UNAME, buf);
 
@@ -73,22 +77,20 @@ int sys_uname(struct utsname *buf) {
 }
 
 int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-    // auto result = syscall(SYS_FUTEX_WAIT, pointer, expected, time);
-    //
-    // if (result < 0) {
-    //     return -result;
-    // }
-    //
+    auto ret = syscall(SYS_FUTEX_WAIT, pointer, expected, time);
+
+    if (int e = sc_error(ret); e)
+        return e;
+
     return 0;
 }
 
 int sys_futex_wake(int *pointer) {
-    // auto result = syscall(SYS_FUTEX_WAKE, pointer);
-    //
-    // if (result < 0) {
-    //     return -result;
-    // }
-    //
+    auto ret = syscall(SYS_FUTEX_WAKE, pointer);
+ 
+    if (int e = sc_error(ret); e)
+        return e;
+
     return 0;
 }
 
@@ -309,7 +311,7 @@ int sys_thread_setname(void *tcb, const char *name) {
 }
 
 void sys_thread_exit() {
-    syscall(SYS_EXIT);
+    syscall(SYS_EXIT, 0);
 	__builtin_trap();
 }
 
diff --git a/sysdeps/aero/generic/filesystem.cpp b/sysdeps/aero/generic/filesystem.cpp
index 33a11f4..4f64ba5 100644
--- a/sysdeps/aero/generic/filesystem.cpp
+++ b/sysdeps/aero/generic/filesystem.cpp
@@ -68,15 +68,22 @@ int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
     return 0;
 }
 
-int sys_open(const char *filename, int flags, mode_t mode, int *fd) {
-    auto result = syscall(SYS_OPEN, 0, filename, strlen(filename), flags);
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+	(void)mode;
 
-    if (result < 0) {
-        return -result;
-    }
+    auto ret = syscall(SYS_OPEN, dirfd, path, strlen(path), flags);
+	if (int e = sc_error(ret); e)
+		return e;
+	*fd = ret;
+	return 0;
+}
 
-    *fd = result;
-    return 0;
+int sys_open(const char *path, int flags, mode_t mode, int *fd) {
+	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+
+int sys_open_dir(const char *path, int *fd) {
+    return sys_open(path, O_DIRECTORY, 0, fd);
 }
 
 int sys_close(int fd) {
@@ -256,10 +263,6 @@ int sys_read_entries(int handle, void *buffer, size_t max_size,
     return 0;
 }
 
-int sys_open_dir(const char *path, int *handle) {
-    return sys_open(path, O_DIRECTORY, 0, handle);
-}
-
 int sys_rename(const char *path, const char *new_path) {
     auto result =
         syscall(SYS_RENAME, path, strlen(path), new_path, strlen(new_path));
@@ -305,6 +308,13 @@ int sys_dup2(int fd, int flags, int newfd) {
 }
 
 int sys_fcntl(int fd, int request, va_list args, int *result_value) {
+    if(request == F_GETLK) {
+		struct flock *lock = va_arg(args, struct flock *);
+		lock->l_type = F_UNLCK;
+		mlibc::infoLogger() << "\e[31mmlibc: F_GETLK is stubbed!\e[39m" << frg::endlog;
+		return 0;
+	}
+
     auto result = syscall(SYS_FCNTL, fd, request, va_arg(args, uint64_t));
 
     if (result < 0) {
diff --git a/sysdeps/aero/generic/sockets.cpp b/sysdeps/aero/generic/sockets.cpp
index 10af36a..bf2602f 100644
--- a/sysdeps/aero/generic/sockets.cpp
+++ b/sysdeps/aero/generic/sockets.cpp
@@ -174,14 +174,10 @@ int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer,
 
 int sys_setsockopt(int fd, int layer, int number, const void *buffer,
                    socklen_t size) {
-    (void)fd;
-    (void)buffer;
-    (void)size;
-
     if (layer == SOL_SOCKET && number == SO_PASSCRED) {
-        mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_PASSCRED) is not "
-                               "implemented correctly\e[39m"
-                            << frg::endlog;
+        auto ret = syscall(SYS_SETSOCKOPT, fd, layer, number, buffer, size);
+        if (int e = sc_error(ret); e)
+            return e;
         return 0;
     } else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
         mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_ATTACH_FILTER) is "
diff --git a/sysdeps/aero/include/aero/syscall.h b/sysdeps/aero/include/aero/syscall.h
index 39c5b65..bd2f489 100644
--- a/sysdeps/aero/include/aero/syscall.h
+++ b/sysdeps/aero/include/aero/syscall.h
@@ -82,6 +82,9 @@
 #define SYS_SOCK_SHUTDOWN 75
 #define SYS_GETPEERNAME 76
 #define SYS_GETSOCKNAME 77
+#define SYS_DEBUG 78
+#define SYS_SETSOCKOPT 79
+#define SYS_GETSOCKOPT 80
 
 // Invalid syscall used to trigger a log error in the kernel (as a hint)
 // so, that we can implement the syscall in the kernel.
diff --git a/sysdeps/aero/include/mlibc/jsmn.h b/sysdeps/aero/include/mlibc/jsmn.h
new file mode 100644
index 0000000..2d8f591
--- /dev/null
+++ b/sysdeps/aero/include/mlibc/jsmn.h
@@ -0,0 +1,474 @@
+/*
+ * MIT License
+ *
+ * Copyright (c) 2010 Serge Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef JSMN_H
+#define JSMN_H
+
+#include <stddef.h>
+
+#define JSMN_PARENT_LINKS
+#define JSMN_STRICT
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef JSMN_STATIC
+#define JSMN_API static
+#else
+#define JSMN_API extern
+#endif
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ * 	o String
+ * 	o Other primitive: number, boolean (true/false) or null
+ */
+typedef enum {
+  JSMN_UNDEFINED = 0,
+  JSMN_OBJECT = 1 << 0,
+  JSMN_ARRAY = 1 << 1,
+  JSMN_STRING = 1 << 2,
+  JSMN_PRIMITIVE = 1 << 3
+} jsmntype_t;
+
+enum jsmnerr {
+  /* Not enough tokens were provided */
+  JSMN_ERROR_NOMEM = -1,
+  /* Invalid character inside JSON string */
+  JSMN_ERROR_INVAL = -2,
+  /* The string is not a full JSON packet, more bytes expected */
+  JSMN_ERROR_PART = -3
+};
+
+/**
+ * JSON token description.
+ * type		type (object, array, string etc.)
+ * start	start position in JSON data string
+ * end		end position in JSON data string
+ */
+typedef struct jsmntok {
+  jsmntype_t type;
+  int start;
+  int end;
+  int size;
+#ifdef JSMN_PARENT_LINKS
+  int parent;
+#endif
+} jsmntok_t;
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string.
+ */
+typedef struct jsmn_parser {
+  unsigned int pos;     /* offset in the JSON string */
+  unsigned int toknext; /* next token to allocate */
+  int toksuper;         /* superior token node, e.g. parent object or array */
+} jsmn_parser;
+
+/**
+ * Create JSON parser over an array of tokens
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser);
+
+/**
+ * Run JSON parser. It parses a JSON data string into and array of tokens, each
+ * describing
+ * a single JSON object.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens);
+
+#ifndef JSMN_HEADER
+/**
+ * Allocates a fresh unused token from the token pool.
+ */
+static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
+                                   const size_t num_tokens) {
+  jsmntok_t *tok;
+  if (parser->toknext >= num_tokens) {
+    return NULL;
+  }
+  tok = &tokens[parser->toknext++];
+  tok->start = tok->end = -1;
+  tok->size = 0;
+#ifdef JSMN_PARENT_LINKS
+  tok->parent = -1;
+#endif
+  return tok;
+}
+
+/**
+ * Fills token type and boundaries.
+ */
+static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
+                            const int start, const int end) {
+  token->type = type;
+  token->start = start;
+  token->end = end;
+  token->size = 0;
+}
+
+/**
+ * Fills next available token with JSON primitive.
+ */
+static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
+                                const size_t len, jsmntok_t *tokens,
+                                const size_t num_tokens) {
+  jsmntok_t *token;
+  int start;
+
+  start = parser->pos;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    switch (js[parser->pos]) {
+#ifndef JSMN_STRICT
+    /* In strict mode primitive must be followed by "," or "}" or "]" */
+    case ':':
+#endif
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+    case ',':
+    case ']':
+    case '}':
+      goto found;
+    default:
+                   /* to quiet a warning from gcc*/
+      break;
+    }
+    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+      parser->pos = start;
+      return JSMN_ERROR_INVAL;
+    }
+  }
+#ifdef JSMN_STRICT
+  /* In strict mode primitive must be followed by a comma/object/array */
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+#endif
+
+found:
+  if (tokens == NULL) {
+    parser->pos--;
+    return 0;
+  }
+  token = jsmn_alloc_token(parser, tokens, num_tokens);
+  if (token == NULL) {
+    parser->pos = start;
+    return JSMN_ERROR_NOMEM;
+  }
+  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+  token->parent = parser->toksuper;
+#endif
+  parser->pos--;
+  return 0;
+}
+
+/**
+ * Fills next token with JSON string.
+ */
+static int jsmn_parse_string(jsmn_parser *parser, const char *js,
+                             const size_t len, jsmntok_t *tokens,
+                             const size_t num_tokens) {
+  jsmntok_t *token;
+
+  int start = parser->pos;
+  
+  /* Skip starting quote */
+  parser->pos++;
+  
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c = js[parser->pos];
+
+    /* Quote: end of string */
+    if (c == '\"') {
+      if (tokens == NULL) {
+        return 0;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        parser->pos = start;
+        return JSMN_ERROR_NOMEM;
+      }
+      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+      token->parent = parser->toksuper;
+#endif
+      return 0;
+    }
+
+    /* Backslash: Quoted symbol expected */
+    if (c == '\\' && parser->pos + 1 < len) {
+      int i;
+      parser->pos++;
+      switch (js[parser->pos]) {
+      /* Allowed escaped symbols */
+      case '\"':
+      case '/':
+      case '\\':
+      case 'b':
+      case 'f':
+      case 'r':
+      case 'n':
+      case 't':
+        break;
+      /* Allows escaped symbol \uXXXX */
+      case 'u':
+        parser->pos++;
+        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
+             i++) {
+          /* If it isn't a hex character we have an error */
+          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
+                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */
+                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
+            parser->pos = start;
+            return JSMN_ERROR_INVAL;
+          }
+          parser->pos++;
+        }
+        parser->pos--;
+        break;
+      /* Unexpected symbol */
+      default:
+        parser->pos = start;
+        return JSMN_ERROR_INVAL;
+      }
+    }
+  }
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+}
+
+/**
+ * Parse JSON string and fill tokens.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens) {
+  int r;
+  int i;
+  jsmntok_t *token;
+  int count = parser->toknext;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c;
+    jsmntype_t type;
+
+    c = js[parser->pos];
+    switch (c) {
+    case '{':
+    case '[':
+      count++;
+      if (tokens == NULL) {
+        break;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        return JSMN_ERROR_NOMEM;
+      }
+      if (parser->toksuper != -1) {
+        jsmntok_t *t = &tokens[parser->toksuper];
+#ifdef JSMN_STRICT
+        /* In strict mode an object or array can't become a key */
+        if (t->type == JSMN_OBJECT) {
+          return JSMN_ERROR_INVAL;
+        }
+#endif
+        t->size++;
+#ifdef JSMN_PARENT_LINKS
+        token->parent = parser->toksuper;
+#endif
+      }
+      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+      token->start = parser->pos;
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case '}':
+    case ']':
+      if (tokens == NULL) {
+        break;
+      }
+      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+#ifdef JSMN_PARENT_LINKS
+      if (parser->toknext < 1) {
+        return JSMN_ERROR_INVAL;
+      }
+      token = &tokens[parser->toknext - 1];
+      for (;;) {
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          token->end = parser->pos + 1;
+          parser->toksuper = token->parent;
+          break;
+        }
+        if (token->parent == -1) {
+          if (token->type != type || parser->toksuper == -1) {
+            return JSMN_ERROR_INVAL;
+          }
+          break;
+        }
+        token = &tokens[token->parent];
+      }
+#else
+      for (i = parser->toknext - 1; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          parser->toksuper = -1;
+          token->end = parser->pos + 1;
+          break;
+        }
+      }
+      /* Error if unmatched closing bracket */
+      if (i == -1) {
+        return JSMN_ERROR_INVAL;
+      }
+      for (; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          parser->toksuper = i;
+          break;
+        }
+      }
+#endif
+      break;
+    case '\"':
+      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+      break;
+    case ':':
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case ',':
+      if (tokens != NULL && parser->toksuper != -1 &&
+          tokens[parser->toksuper].type != JSMN_ARRAY &&
+          tokens[parser->toksuper].type != JSMN_OBJECT) {
+#ifdef JSMN_PARENT_LINKS
+        parser->toksuper = tokens[parser->toksuper].parent;
+#else
+        for (i = parser->toknext - 1; i >= 0; i--) {
+          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
+            if (tokens[i].start != -1 && tokens[i].end == -1) {
+              parser->toksuper = i;
+              break;
+            }
+          }
+        }
+#endif
+      }
+      break;
+#ifdef JSMN_STRICT
+    /* In strict mode primitives are: numbers and booleans */
+    case '-':
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+    case 't':
+    case 'f':
+    case 'n':
+      /* And they must not be keys of the object */
+      if (tokens != NULL && parser->toksuper != -1) {
+        const jsmntok_t *t = &tokens[parser->toksuper];
+        if (t->type == JSMN_OBJECT ||
+            (t->type == JSMN_STRING && t->size != 0)) {
+          return JSMN_ERROR_INVAL;
+        }
+      }
+#else
+    /* In non-strict mode every unquoted value is a primitive */
+    default:
+#endif
+      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+
+#ifdef JSMN_STRICT
+    /* Unexpected char in strict mode */
+    default:
+      return JSMN_ERROR_INVAL;
+#endif
+    }
+  }
+
+  if (tokens != NULL) {
+    for (i = parser->toknext - 1; i >= 0; i--) {
+      /* Unmatched opened object or array */
+      if (tokens[i].start != -1 && tokens[i].end == -1) {
+        return JSMN_ERROR_PART;
+      }
+    }
+  }
+
+  return count;
+}
+
+/**
+ * Creates a new parser based over a given buffer with an array of tokens
+ * available.
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser) {
+  parser->pos = 0;
+  parser->toknext = 0;
+  parser->toksuper = -1;
+}
+
+#endif /* JSMN_HEADER */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* JSMN_H */
-- 
2.43.0

