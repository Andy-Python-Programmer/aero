From 2167f1570f20a986de9b3c81636d78e4ef1cedb8 Mon Sep 17 00:00:00 2001
From: Andy-Python-Programmer <andypythonappdeveloper@gmail.com>
Date: Fri, 8 Jul 2022 12:32:32 +1000
Subject: [PATCH] yes

Signed-off-by: Andy-Python-Programmer <andypythonappdeveloper@gmail.com>
---
 .gitignore                            |   2 +
 options/ansi/generic/stdlib-stubs.cpp | 142 +++++++++++++++++++++-----
 options/glibc/generic/execinfo.cpp    |   5 +-
 options/rtdl/generic/linker.cpp       |   2 +-
 sysdeps/aero/generic/aero.cpp         |  38 +++----
 sysdeps/aero/generic/filesystem.cpp   |  25 ++++-
 sysdeps/aero/generic/sockets.cpp      |  77 +++++++++++++-
 sysdeps/aero/include/aero/syscall.h   |   4 +
 8 files changed, 241 insertions(+), 54 deletions(-)

diff --git a/.gitignore b/.gitignore
index fdd60a00..9f811f47 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,5 @@ subprojects
 *.xbstrap
 # editor configs:
 .vscode
+# clangd cache files:
+.cache
diff --git a/options/ansi/generic/stdlib-stubs.cpp b/options/ansi/generic/stdlib-stubs.cpp
index 4836391e..2a73c6d0 100644
--- a/options/ansi/generic/stdlib-stubs.cpp
+++ b/options/ansi/generic/stdlib-stubs.cpp
@@ -375,32 +375,122 @@ int mblen(const char *mbs, size_t mb_limit) {
 	return nseq.it - mbs;
 }
 
-int mbtowc(wchar_t *__restrict wc, const char *__restrict mb, size_t max_size) {
-	auto cc = mlibc::current_charcode();
-	__ensure(max_size);
-
-	if (mb) {
-		if (*mb) {
-			// If wc is NULL, decode into a single local character which we discard
-			// to obtain the length.
-			wchar_t tmp_wc;
-			if (!wc)
-				wc = &tmp_wc;
-
-			mlibc::code_seq<wchar_t> wseq{wc, wc + 1};
-			mlibc::code_seq<const char> nseq{mb, mb + max_size};
-			auto e = cc->decode_wtranscode(nseq, wseq, mbtowc_state);
-			if (e != mlibc::charcode_error::null)
-				__ensure(!"decode_wtranscode() errors are not handled");
-
-			return nseq.it - mb;
-		} else {
-			return 0; // When mbs is a null byte, return 0
-		}
-	} else {
-		mblen_state = __MLIBC_MBSTATE_INITIALIZER;
-		return cc->has_shift_states;
-	}
+// int mbtowc(wchar_t *__restrict wc, const char *__restrict mb, size_t max_size) {
+// 	auto cc = mlibc::current_charcode();
+// 	__ensure(max_size);
+//
+// 	if (mb) {
+// 		if (*mb) {
+// 			// If wc is NULL, decode into a single local character which we discard
+// 			// to obtain the length.
+// 			wchar_t tmp_wc;
+// 			if (!wc)
+// 				wc = &tmp_wc;
+//
+// 			mlibc::code_seq<wchar_t> wseq{wc, wc + 1};
+// 			mlibc::code_seq<const char> nseq{mb, mb + max_size};
+// 			auto e = cc->decode_wtranscode(nseq, wseq, mbtowc_state);
+// 			if (e != mlibc::charcode_error::null)
+// 				__ensure(!"decode_wtranscode() errors are not handled");
+//
+// 			return nseq.it - mb;
+// 		} else {
+// 			return 0; // When mbs is a null byte, return 0
+// 		}
+// 	} else {
+// 		mblen_state = __MLIBC_MBSTATE_INITIALIZER;
+// 		return cc->has_shift_states;
+// 	}
+// }
+
+// Upper 6 state bits are a negative integer offset to bound-check next byte
+//    equivalent to: ( (b-0x80) | (b+offset) ) & ~0x3f
+#define OOB(c, b) (((((b) >> 3) - 0x10) | (((b) >> 3) + ((int32_t)(c) >> 26))) & ~7)
+
+// Interval [a,b]. Either a must be 80 or b must be c0, lower 3 bits clear.
+#define R(a, b) ((uint32_t)((a == 0x80 ? 0x40u - b : 0u - a) << 23))
+#define FAILSTATE R(0x80, 0x80)
+
+#define SA 0xc2u
+#define SB 0xf4u
+
+// Arbitrary encoding for representing code units instead of characters.
+#define CODEUNIT(c) (0xdfff & (signed char)(c))
+#define IS_CODEUNIT(c) ((unsigned)(c)-0xdf80 < 0x80)
+
+#define C(x) ( x<2 ? -1 : ( R(0x80,0xc0) | x ) )
+#define D(x) C((x+16))
+#define E(x) ( ( x==0 ? R(0xa0,0xc0) : \
+                 x==0xd ? R(0x80,0xa0) : \
+                 R(0x80,0xc0) ) \
+             | ( R(0x80,0xc0) >> 6 ) \
+             | x )
+#define F(x) ( ( x>=5 ? 0 : \
+                 x==0 ? R(0x90,0xc0) : \
+                 x==4 ? R(0x80,0xa0) : \
+                 R(0x80,0xc0) ) \
+             | ( R(0x80,0xc0) >> 6 ) \
+             | ( R(0x80,0xc0) >> 12 ) \
+             | x )
+
+const uint32_t bittab[] = {
+	C(0x2),C(0x3),C(0x4),C(0x5),C(0x6),C(0x7),
+	C(0x8),C(0x9),C(0xa),C(0xb),C(0xc),C(0xd),C(0xe),C(0xf),
+	D(0x0),D(0x1),D(0x2),D(0x3),D(0x4),D(0x5),D(0x6),D(0x7),
+	D(0x8),D(0x9),D(0xa),D(0xb),D(0xc),D(0xd),D(0xe),D(0xf),
+	E(0x0),E(0x1),E(0x2),E(0x3),E(0x4),E(0x5),E(0x6),E(0x7),
+	E(0x8),E(0x9),E(0xa),E(0xb),E(0xc),E(0xd),E(0xe),E(0xf),
+	F(0x0),F(0x1),F(0x2),F(0x3),F(0x4)
+};
+
+// Converts a multibyte sequence to a wide character.
+//
+// Credits - MUSL
+int mbtowc(wchar_t *__restrict wc, const char *__restrict src, size_t n) {
+	unsigned c;
+	const unsigned char *s = static_cast<const unsigned char *>((const void *)src);
+	wchar_t dummy;
+
+  	if (!s) return 0;
+  	if (!n) goto ilseq;
+  	if (!wc) wc = &dummy;
+
+  	if (*s < 0x80) return !!(*wc = *s);
+	if (MB_CUR_MAX == 1) return (*wc = CODEUNIT(*s)), 1;
+  	if (*s - SA > SB - SA) goto ilseq;
+  	
+	c = bittab[*s++ - SA];
+
+  	// Avoid excessive checks against n: If shifting the state n-1
+	// times does not clear the high bit, then the value of n is
+	// insufficient to read a character.
+  	if (n < 4 && ((c << (6 * n - 6)) & (1U << 31))) goto ilseq;
+  	if (OOB(c, *s)) goto ilseq;
+  	
+	c = c << 6 | (*s++ - 0x80);
+  	
+	if (!(c & (1U << 31))) {
+    	*wc = c;
+    	return 2;
+  	}
+
+  	if (*s - 0x80u >= 0x40) goto ilseq;
+  	
+	c = c << 6 | (*s++ - 0x80);
+  	
+	if (!(c & (1U << 31))) {
+    	*wc = c;
+    	return 3;
+  	}
+
+  	if (*s - 0x80u >= 0x40) goto ilseq;
+	
+	*wc = c << 6 | (*s++ - 0x80);
+	return 4;
+
+ilseq:
+	errno = EILSEQ;
+	return -1;
 }
 
 int wctomb(char *, wchar_t) {
diff --git a/options/glibc/generic/execinfo.cpp b/options/glibc/generic/execinfo.cpp
index 3474615e..10a2109e 100644
--- a/options/glibc/generic/execinfo.cpp
+++ b/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,10 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/debug.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "backtrace() is unimplemented" << frg::endlog;
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git a/options/rtdl/generic/linker.cpp b/options/rtdl/generic/linker.cpp
index 6716ef4f..e5ec8cff 100644
--- a/options/rtdl/generic/linker.cpp
+++ b/options/rtdl/generic/linker.cpp
@@ -15,7 +15,7 @@ uintptr_t libraryBase = 0x41000000;
 
 constexpr bool verbose = false;
 constexpr bool stillSlightlyVerbose = false;
-constexpr bool logBaseAddresses = false;
+constexpr bool logBaseAddresses = true;
 constexpr bool logRpath = false;
 constexpr bool eagerBinding = true;
 
diff --git a/sysdeps/aero/generic/aero.cpp b/sysdeps/aero/generic/aero.cpp
index 29fb9610..a27da559 100644
--- a/sysdeps/aero/generic/aero.cpp
+++ b/sysdeps/aero/generic/aero.cpp
@@ -69,22 +69,22 @@ int sys_futex_tid() {
 }
 
 int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-    auto result = syscall(SYS_FUTEX_WAIT, pointer, expected, time);
-
-    if (result < 0) {
-        return -result;
-    }
-
+    // auto result = syscall(SYS_FUTEX_WAIT, pointer, expected, time);
+    //
+    // if (result < 0) {
+    //     return -result;
+    // }
+    //
     return 0;
 }
 
 int sys_futex_wake(int *pointer) {
-    auto result = syscall(SYS_FUTEX_WAKE, pointer);
-
-    if (result < 0) {
-        return -result;
-    }
-
+    // auto result = syscall(SYS_FUTEX_WAKE, pointer);
+    //
+    // if (result < 0) {
+    //     return -result;
+    // }
+    //
     return 0;
 }
 
@@ -124,7 +124,9 @@ int sys_anon_free(void *pointer, size_t size) {
 }
 
 void sys_libc_panic() {
-    sys_libc_log("libc panic!");
+    mlibc::infoLogger() << "libc_panic: panicked at 'unknown'" << frg::endlog;
+    __ensure(!syscall(SYS_BACKTRACE));
+
     sys_exit(1);
 }
 
@@ -233,7 +235,7 @@ uid_t sys_geteuid() {
     return 0;
 }
 
-int sys_setuid(uid_t uid) UNIMPLEMENTED("sys_setuid")
+// int sys_setuid(uid_t uid) UNIMPLEMENTED("sys_setuid")
 int sys_seteuid(uid_t euid) UNIMPLEMENTED("sys_seteuid")
 
 gid_t sys_getgid() {
@@ -259,13 +261,13 @@ int sys_setegid(gid_t egid) {
 void sys_yield() UNIMPLEMENTED("sys_yield")
 
 int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
-    auto tid = syscall(SYS_CLONE, (uintptr_t)__mlibc_start_thread, stack);
+    auto result = syscall(SYS_CLONE, (uintptr_t)__mlibc_start_thread, stack);
 
-    if (tid < 0) {
-        return -tid;
+    if (result < 0) {
+        return -result;
     }
 
-    *tid_out = (pid_t)tid;
+    *tid_out = (pid_t)result;
     return 0;
 }
 
diff --git a/sysdeps/aero/generic/filesystem.cpp b/sysdeps/aero/generic/filesystem.cpp
index a3e2aca2..4187059e 100644
--- a/sysdeps/aero/generic/filesystem.cpp
+++ b/sysdeps/aero/generic/filesystem.cpp
@@ -158,11 +158,6 @@ int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
     return 0;
 }
 
-int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
-    mlibc::infoLogger() << "sys_poll() is not implemented" << frg::endlog;
-    return 0;
-}
-
 int sys_mkdir(const char *path, mode_t) {
     auto result = syscall(SYS_MKDIR, path, strlen(path));
 
@@ -357,4 +352,24 @@ int sys_eventfd_create(unsigned int initval, int flags, int *fd) {
     *fd = result;
     return 0;
 }
+
+int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout,
+		const sigset_t *sigmask, int *num_events) {
+    auto result = syscall(SYS_POLL, fds, nfds, timeout, sigmask);
+
+    if (result < 0) {
+        return -result;
+    }
+
+    *num_events = result;
+    return 0;
+}
+
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
+    struct timespec ts;
+    ts.tv_sec = timeout / 1000;
+    ts.tv_nsec = (timeout % 1000) * 1000000;
+
+    return sys_ppoll(fds, count, &ts, NULL, num_events);
+}
 } // namespace mlibc
diff --git a/sysdeps/aero/generic/sockets.cpp b/sysdeps/aero/generic/sockets.cpp
index b6b18fe7..e03c634b 100644
--- a/sysdeps/aero/generic/sockets.cpp
+++ b/sysdeps/aero/generic/sockets.cpp
@@ -1,5 +1,6 @@
 #include <mlibc/all-sysdeps.hpp>
 #include <mlibc/thread-entry.hpp>
+#include <mlibc/debug.hpp>
 
 #include <aero/syscall.h>
 #include <stdint.h>
@@ -46,8 +47,8 @@ int sys_listen(int fd, int backlog) {
     return 0;
 }
 
-int sys_accept(int fd, int *newfd) {
-    auto result = syscall(SYS_ACCEPT, fd);
+int sys_accept(int sockfd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length) {
+    auto result = syscall(SYS_ACCEPT, sockfd, addr_ptr, addr_length);
 
     if (result < 0) {
         return -result;
@@ -56,4 +57,76 @@ int sys_accept(int fd, int *newfd) {
     *newfd = result;
     return 0;
 }
+
+
+int sys_msg_recv(int sockfd, struct msghdr *msg_hdr, int flags, ssize_t *length) {
+	auto result = syscall(SYS_SOCK_RECV, sockfd, msg_hdr, flags);
+	
+	if (result < 0) {
+		return -result;
+	}
+
+	*length = result;
+	return 0;
+}
+
+int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) {
+	(void)fd; (void)size;
+	if (layer == SOL_SOCKET && number == SO_PEERCRED) {
+		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented\e[39m" << frg::endlog;
+		*(int *)buffer = 0;
+		return 0;
+	} else if(layer == SOL_SOCKET && number == SO_SNDBUF) {
+		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented\e[39m" << frg::endlog;
+		*(int *)buffer = 4096;
+		return 0;
+	} else if(layer == SOL_SOCKET && number == SO_TYPE) {
+		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM\e[39m" << frg::endlog;
+		*(int *)buffer = SOCK_STREAM;
+		return 0;
+	} else if(layer == SOL_SOCKET && number == SO_ERROR) {
+		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0\e[39m" << frg::endlog;
+		*(int *)buffer = 0;
+		return 0;
+	} else if(layer == SOL_SOCKET && number == SO_KEEPALIVE) {
+		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0\e[39m" << frg::endlog;
+		*(int *)buffer = 0;
+		return 0;
+	} else{
+		mlibc::panicLogger() << "\e[31mmlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << "\e[39m" << frg::endlog;
+		__builtin_unreachable();
+	}
+
+	return 0;
+}
+
+int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) {
+	(void)fd; (void)buffer; (void)size;
+
+	if (layer == SOL_SOCKET && number == SO_PASSCRED) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_PASSCRED) is not implemented correctly\e[39m" << frg::endlog;
+		return 0;
+	} else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly\e[39m" << frg::endlog;
+		return 0;
+	} else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly\e[39m" << frg::endlog;
+		return 0;
+	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented\e[39m" << frg::endlog;
+		return 0;
+	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented\e[39m" << frg::endlog;
+		return 0;
+	} else if (layer == SOL_SOCKET && number == SO_REUSEADDR) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented\e[39m" << frg::endlog;
+		return 0;
+	} else if (layer == AF_NETLINK && number == SO_ACCEPTCONN) {
+		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented\e[39m" << frg::endlog;
+		return 0;
+	} else {
+		mlibc::panicLogger() << "\e[31mmlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << "\e[39m" << frg::endlog;
+		__builtin_unreachable();
+	}
+}
 } // namespace mlibc
diff --git a/sysdeps/aero/include/aero/syscall.h b/sysdeps/aero/include/aero/syscall.h
index 12f8dc61..50f8cfa7 100644
--- a/sysdeps/aero/include/aero/syscall.h
+++ b/sysdeps/aero/include/aero/syscall.h
@@ -64,6 +64,10 @@
 #define SYS_FUTEX_WAIT 57
 #define SYS_FUTEX_WAKE 58
 #define SYS_LINK 59
+#define SYS_BACKTRACE 60
+#define SYS_POLL 61
+#define SYS_EXIT_THREAD 62
+#define SYS_SOCK_RECV 63
 
 // Invalid syscall used to trigger a log error in the kernel (as a hint)
 // so, that we can implement the syscall in the kernel.
-- 
2.25.1

