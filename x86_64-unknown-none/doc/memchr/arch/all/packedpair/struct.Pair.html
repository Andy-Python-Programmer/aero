<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A pair of byte offsets into a needle to use as a predicate."><title>Pair in memchr::arch::all::packedpair - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-de575e9a.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="memchr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (2fa8b11f0 2025-04-06)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../memchr/index.html">memchr</a><span class="version">2.7.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Pair</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.index1" title="index1">index1</a></li><li><a href="#method.index2" title="index2">index2</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.with_indices" title="with_indices">with_indices</a></li><li><a href="#method.with_ranker" title="with_ranker">with_ranker</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Pair" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Pair" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Pair" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Pair" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Pair" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Pair" title="Send">Send</a></li><li><a href="#impl-Sync-for-Pair" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Pair" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Pair" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In memchr::<wbr>arch::<wbr>all::<wbr>packedpair</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">memchr</a>::<wbr><a href="../../index.html">arch</a>::<wbr><a href="../index.html">all</a>::<wbr><a href="index.html">packedpair</a></div><h1>Struct <span class="struct">Pair</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#135-138">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Pair { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A pair of byte offsets into a needle to use as a predicate.</p>
<p>This pair is used as a predicate to quickly filter out positions in a
haystack in which a needle cannot match. In some cases, this pair can even
be used in vector algorithms such that the vector algorithm only switches
over to scalar code once this pair has been found.</p>
<p>A pair of offsets can be used in both substring search implementations and
in prefilters. The former will report matches of a needle in a haystack
where as the latter will only report possible matches of a needle.</p>
<p>The offsets are limited each to a maximum of 255 to keep memory usage low.
Moreover, it’s rarely advantageous to create a predicate using offsets
greater than 255 anyway.</p>
<p>The only guarantee enforced on the pair of offsets is that they are not
equivalent. It is not necessarily the case that <code>index1 &lt; index2</code> for
example. By convention, <code>index1</code> corresponds to the byte in the needle
that is believed to be most the predictive. Note also that because of the
requirement that the indices be both valid for the needle used to build
the pair and not equal, it follows that a pair can only be constructed for
needles with length at least 2.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Pair" class="impl"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#140-247">Source</a><a href="#impl-Pair" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#149-151">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(needle: &amp;[u8]) -&gt; Option&lt;<a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new pair of offsets from the given needle.</p>
<p>If a pair could not be created (for example, if the needle is too
short), then <code>None</code> is returned.</p>
<p>This chooses the pair in the needle that is believed to be as
predictive of an overall match of the needle as possible.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_ranker" class="method"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#163-197">Source</a><h4 class="code-header">pub fn <a href="#method.with_ranker" class="fn">with_ranker</a>&lt;R: <a class="trait" href="trait.HeuristicFrequencyRank.html" title="trait memchr::arch::all::packedpair::HeuristicFrequencyRank">HeuristicFrequencyRank</a>&gt;(
    needle: &amp;[u8],
    ranker: R,
) -&gt; Option&lt;<a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new pair of offsets from the given needle and ranker.</p>
<p>This permits the caller to choose a background frequency distribution
with which bytes are selected. The idea is to select a pair of bytes
that is believed to strongly predict a match in the haystack. This
usually means selecting bytes that occur rarely in a haystack.</p>
<p>If a pair could not be created (for example, if the needle is too
short), then <code>None</code> is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_indices" class="method"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#214-234">Source</a><h4 class="code-header">pub fn <a href="#method.with_indices" class="fn">with_indices</a>(needle: &amp;[u8], index1: u8, index2: u8) -&gt; Option&lt;<a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new pair using the offsets given for the needle given.</p>
<p>This bypasses any sort of heuristic process for choosing the offsets
and permits the caller to choose the offsets themselves.</p>
<p>Indices are limited to valid <code>u8</code> values so that a <code>Pair</code> uses less
memory. It is not possible to create a <code>Pair</code> with offsets bigger than
<code>u8::MAX</code>. It’s likely that such a thing is not needed, but if it is,
it’s suggested to build your own bespoke algorithm because you’re
likely working on a very niche case. (File an issue if this suggestion
does not make sense to you.)</p>
<p>If a pair could not be created (for example, if the needle is too
short), then <code>None</code> is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.index1" class="method"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#238-240">Source</a><h4 class="code-header">pub fn <a href="#method.index1" class="fn">index1</a>(&amp;self) -&gt; u8</h4></section></summary><div class="docblock"><p>Returns the first offset of the pair.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.index2" class="method"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#244-246">Source</a><h4 class="code-header">pub fn <a href="#method.index2" class="fn">index2</a>(&amp;self) -&gt; u8</h4></section></summary><div class="docblock"><p>Returns the second offset of the pair.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Pair" class="impl"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#134">Source</a><a href="#impl-Clone-for-Pair" class="anchor">§</a><h3 class="code-header">impl Clone for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#134">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Pair" class="impl"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#134">Source</a><a href="#impl-Debug-for-Pair" class="anchor">§</a><h3 class="code-header">impl Debug for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#134">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details><section id="impl-Copy-for-Pair" class="impl"><a class="src rightside" href="../../../../src/memchr/arch/all/packedpair/mod.rs.html#134">Source</a><a href="#impl-Copy-for-Pair" class="anchor">§</a><h3 class="code-header">impl Copy for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Pair" class="impl"><a href="#impl-Freeze-for-Pair" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section><section id="impl-RefUnwindSafe-for-Pair" class="impl"><a href="#impl-RefUnwindSafe-for-Pair" class="anchor">§</a><h3 class="code-header">impl RefUnwindSafe for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section><section id="impl-Send-for-Pair" class="impl"><a href="#impl-Send-for-Pair" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section><section id="impl-Sync-for-Pair" class="impl"><a href="#impl-Sync-for-Pair" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section><section id="impl-Unpin-for-Pair" class="impl"><a href="#impl-Unpin-for-Pair" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section><section id="impl-UnwindSafe-for-Pair" class="impl"><a href="#impl-UnwindSafe-for-Pair" class="anchor">§</a><h3 class="code-header">impl UnwindSafe for <a class="struct" href="struct.Pair.html" title="struct memchr::arch::all::packedpair::Pair">Pair</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneToUninit for T<div class="where">where
    T: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">clone_to_uninit</a>(&amp;self, dest: *mut u8)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>