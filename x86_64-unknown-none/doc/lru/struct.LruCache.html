<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An LRU Cache"><title>LruCache in lru - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-de575e9a.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="lru" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (2fa8b11f0 2025-04-06)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../lru/index.html">lru</a><span class="version">0.13.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">LruCache</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.cap" title="cap">cap</a></li><li><a href="#method.clear" title="clear">clear</a></li><li><a href="#method.contains" title="contains">contains</a></li><li><a href="#method.demote" title="demote">demote</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_key_value" title="get_key_value">get_key_value</a></li><li><a href="#method.get_key_value_mut" title="get_key_value_mut">get_key_value_mut</a></li><li><a href="#method.get_mut" title="get_mut">get_mut</a></li><li><a href="#method.get_or_insert" title="get_or_insert">get_or_insert</a></li><li><a href="#method.get_or_insert_mut" title="get_or_insert_mut">get_or_insert_mut</a></li><li><a href="#method.get_or_insert_mut_ref" title="get_or_insert_mut_ref">get_or_insert_mut_ref</a></li><li><a href="#method.get_or_insert_ref" title="get_or_insert_ref">get_or_insert_ref</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.iter" title="iter">iter</a></li><li><a href="#method.iter_mut" title="iter_mut">iter_mut</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.peek" title="peek">peek</a></li><li><a href="#method.peek_lru" title="peek_lru">peek_lru</a></li><li><a href="#method.peek_mru" title="peek_mru">peek_mru</a></li><li><a href="#method.peek_mut" title="peek_mut">peek_mut</a></li><li><a href="#method.pop" title="pop">pop</a></li><li><a href="#method.pop_entry" title="pop_entry">pop_entry</a></li><li><a href="#method.pop_lru" title="pop_lru">pop_lru</a></li><li><a href="#method.pop_mru" title="pop_mru">pop_mru</a></li><li><a href="#method.promote" title="promote">promote</a></li><li><a href="#method.push" title="push">push</a></li><li><a href="#method.put" title="put">put</a></li><li><a href="#method.resize" title="resize">resize</a></li><li><a href="#method.try_get_or_insert" title="try_get_or_insert">try_get_or_insert</a></li><li><a href="#method.try_get_or_insert_mut" title="try_get_or_insert_mut">try_get_or_insert_mut</a></li><li><a href="#method.try_get_or_insert_mut_ref" title="try_get_or_insert_mut_ref">try_get_or_insert_mut_ref</a></li><li><a href="#method.try_get_or_insert_ref" title="try_get_or_insert_ref">try_get_or_insert_ref</a></li><li><a href="#method.unbounded" title="unbounded">unbounded</a></li><li><a href="#method.unbounded_with_hasher" title="unbounded_with_hasher">unbounded_with_hasher</a></li><li><a href="#method.with_hasher" title="with_hasher">with_hasher</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-LruCache%3CK,+V%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-LruCache%3CK,+V,+S%3E" title="Debug">Debug</a></li><li><a href="#impl-Drop-for-LruCache%3CK,+V,+S%3E" title="Drop">Drop</a></li><li><a href="#impl-IntoIterator-for-%26LruCache%3CK,+V,+S%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-%26mut+LruCache%3CK,+V,+S%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-IntoIterator-for-LruCache%3CK,+V%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-Send-for-LruCache%3CK,+V,+S%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-LruCache%3CK,+V,+S%3E" title="Sync">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-LruCache%3CK,+V,+S%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-LruCache%3CK,+V,+S%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-LruCache%3CK,+V,+S%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-LruCache%3CK,+V,+S%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate lru</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">lru</a></div><h1>Struct <span class="struct">LruCache</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/lru/lib.rs.html#187-194">Source</a> </span></div><pre class="rust item-decl"><code>pub struct LruCache&lt;K, V, S = <a class="type" href="type.DefaultHasher.html" title="type lru::DefaultHasher">DefaultHasher</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An LRU Cache</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-LruCache%3CK,+V%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#212-238">Source</a><a href="#impl-LruCache%3CK,+V%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Hash + Eq, V&gt; <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#222-224">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(cap: NonZeroUsize) -&gt; <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Creates a new LRU Cache that holds at most <code>cap</code> items.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::new(NonZeroUsize::new(<span class="number">10</span>).unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unbounded" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#235-237">Source</a><h4 class="code-header">pub fn <a href="#method.unbounded" class="fn">unbounded</a>() -&gt; <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V&gt;</h4></section></summary><div class="docblock"><p>Creates a new LRU Cache that never automatically evicts items.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::unbounded();</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#240-1560">Source</a><a href="#impl-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Hash + Eq, V, S: BuildHasher&gt; <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_hasher" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#253-258">Source</a><h4 class="code-header">pub fn <a href="#method.with_hasher" class="fn">with_hasher</a>(cap: NonZeroUsize, hash_builder: S) -&gt; <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h4></section></summary><div class="docblock"><p>Creates a new LRU Cache that holds at most <code>cap</code> items and
uses the provided hash builder to hash keys.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::{LruCache, DefaultHasher};
<span class="kw">use </span>std::num::NonZeroUsize;

<span class="kw">let </span>s = DefaultHasher::default();
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::with_hasher(NonZeroUsize::new(<span class="number">10</span>).unwrap(), s);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unbounded_with_hasher" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#271-276">Source</a><h4 class="code-header">pub fn <a href="#method.unbounded_with_hasher" class="fn">unbounded_with_hasher</a>(hash_builder: S) -&gt; <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h4></section></summary><div class="docblock"><p>Creates a new LRU Cache that never automatically evicts items and
uses the provided hash builder to hash keys.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::{LruCache, DefaultHasher};

<span class="kw">let </span>s = DefaultHasher::default();
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::unbounded_with_hasher(s);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.put" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#317-319">Source</a><h4 class="code-header">pub fn <a href="#method.put" class="fn">put</a>(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt;</h4></section></summary><div class="docblock"><p>Puts a key-value pair into cache. If the key already exists in the cache, then it updates
the key’s value and returns the old value. Otherwise, <code>None</code> is returned.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, cache.put(<span class="number">1</span>, <span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, cache.put(<span class="number">2</span>, <span class="string">"b"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"b"</span>), cache.put(<span class="number">2</span>, <span class="string">"beta"</span>));

<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"beta"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#345-347">Source</a><h4 class="code-header">pub fn <a href="#method.push" class="fn">push</a>(&amp;mut self, k: K, v: V) -&gt; Option&lt;(K, V)&gt;</h4></section></summary><div class="docblock"><p>Pushes a key-value pair into the cache. If an entry with key <code>k</code> already exists in
the cache or another cache entry is removed (due to the lru’s capacity),
then it returns the old entry’s key-value pair. Otherwise, returns <code>None</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, cache.push(<span class="number">1</span>, <span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, cache.push(<span class="number">2</span>, <span class="string">"b"</span>));

<span class="comment">// This push call returns (2, "b") because that was previously 2's entry in the cache.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">"b"</span>)), cache.push(<span class="number">2</span>, <span class="string">"beta"</span>));

<span class="comment">// This push call returns (1, "a") because the cache is at capacity and 1's entry was the lru entry.
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">"a"</span>)), cache.push(<span class="number">3</span>, <span class="string">"alpha"</span>));

<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"beta"</span>));
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"alpha"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#435-450">Source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;'a, Q&gt;(&amp;'a mut self, k: &amp;Q) -&gt; Option&lt;&amp;'a V&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a reference to the value of the key in the cache or <code>None</code> if it is not
present in the cache. Moves the key to the head of the LRU list if it exists.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">2</span>, <span class="string">"c"</span>);
cache.put(<span class="number">3</span>, <span class="string">"d"</span>);

<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"c"</span>));
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"d"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#471-486">Source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;'a, Q&gt;(&amp;'a mut self, k: &amp;Q) -&gt; Option&lt;&amp;'a mut V&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value of the key in the cache or <code>None</code> if it
is not present in the cache. Moves the key to the head of the LRU list if it exists.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="string">"apple"</span>, <span class="number">8</span>);
cache.put(<span class="string">"banana"</span>, <span class="number">4</span>);
cache.put(<span class="string">"banana"</span>, <span class="number">6</span>);
cache.put(<span class="string">"pear"</span>, <span class="number">2</span>);

<span class="macro">assert_eq!</span>(cache.get_mut(<span class="kw-2">&amp;</span><span class="string">"apple"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.get_mut(<span class="kw-2">&amp;</span><span class="string">"banana"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="number">6</span>));
<span class="macro">assert_eq!</span>(cache.get_mut(<span class="kw-2">&amp;</span><span class="string">"pear"</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="number">2</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_key_value" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#507-522">Source</a><h4 class="code-header">pub fn <a href="#method.get_key_value" class="fn">get_key_value</a>&lt;'a, Q&gt;(&amp;'a mut self, k: &amp;Q) -&gt; Option&lt;(&amp;'a K, &amp;'a V)&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a key-value references pair of the key in the cache or <code>None</code> if it is not
present in the cache. Moves the key to the head of the LRU list if it exists.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(String::from(<span class="string">"1"</span>), <span class="string">"a"</span>);
cache.put(String::from(<span class="string">"2"</span>), <span class="string">"b"</span>);
cache.put(String::from(<span class="string">"2"</span>), <span class="string">"c"</span>);
cache.put(String::from(<span class="string">"3"</span>), <span class="string">"d"</span>);

<span class="macro">assert_eq!</span>(cache.get_key_value(<span class="string">"1"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.get_key_value(<span class="string">"2"</span>), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span>String::from(<span class="string">"2"</span>), <span class="kw-2">&amp;</span><span class="string">"c"</span>)));
<span class="macro">assert_eq!</span>(cache.get_key_value(<span class="string">"3"</span>), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span>String::from(<span class="string">"3"</span>), <span class="kw-2">&amp;</span><span class="string">"d"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_key_value_mut" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#546-566">Source</a><h4 class="code-header">pub fn <a href="#method.get_key_value_mut" class="fn">get_key_value_mut</a>&lt;'a, Q&gt;(
    &amp;'a mut self,
    k: &amp;Q,
) -&gt; Option&lt;(&amp;'a K, &amp;'a mut V)&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a key-value references pair of the key in the cache or <code>None</code> if it is not
present in the cache. The reference to the value of the key is mutable. Moves the key to
the head of the LRU list if it exists.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
<span class="kw">let </span>(k, v) = cache.get_key_value_mut(<span class="kw-2">&amp;</span><span class="number">1</span>).unwrap();
<span class="macro">assert_eq!</span>(k, <span class="kw-2">&amp;</span><span class="number">1</span>);
<span class="macro">assert_eq!</span>(v, <span class="kw-2">&amp;mut </span><span class="string">"a"</span>);
<span class="kw-2">*</span>v = <span class="string">"aa"</span>;
cache.put(<span class="number">3</span>, <span class="string">"c"</span>);
<span class="macro">assert_eq!</span>(cache.get_key_value(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.get_key_value(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="string">"aa"</span>)));
<span class="macro">assert_eq!</span>(cache.get_key_value(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="number">3</span>, <span class="kw-2">&amp;</span><span class="string">"c"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_or_insert" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#590-612">Source</a><h4 class="code-header">pub fn <a href="#method.get_or_insert" class="fn">get_or_insert</a>&lt;F&gt;(&amp;mut self, k: K, f: F) -&gt; &amp;V<div class="where">where
    F: FnOnce() -&gt; V,</div></h4></section></summary><div class="docblock"><p>Returns a reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a reference is returned.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">2</span>, <span class="string">"c"</span>);
cache.put(<span class="number">3</span>, <span class="string">"d"</span>);

<span class="macro">assert_eq!</span>(cache.get_or_insert(<span class="number">2</span>, ||<span class="string">"a"</span>), <span class="kw-2">&amp;</span><span class="string">"c"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert(<span class="number">3</span>, ||<span class="string">"a"</span>), <span class="kw-2">&amp;</span><span class="string">"d"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert(<span class="number">1</span>, ||<span class="string">"a"</span>), <span class="kw-2">&amp;</span><span class="string">"a"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert(<span class="number">1</span>, ||<span class="string">"b"</span>), <span class="kw-2">&amp;</span><span class="string">"a"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_or_insert_ref" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#639-663">Source</a><h4 class="code-header">pub fn <a href="#method.get_or_insert_ref" class="fn">get_or_insert_ref</a>&lt;'a, Q, F&gt;(&amp;'a mut self, k: &amp;Q, f: F) -&gt; &amp;'a V<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized + ToOwned&lt;Owned = K&gt;,
    F: FnOnce() -&gt; V,</div></h4></section></summary><div class="docblock"><p>Returns a reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a reference is returned. The value referenced by the
key is only cloned (using <code>to_owned()</code>) if it doesn’t exist in the
cache.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">use </span>std::rc::Rc;

<span class="kw">let </span>key1 = Rc::new(<span class="string">"1"</span>.to_owned());
<span class="kw">let </span>key2 = Rc::new(<span class="string">"2"</span>.to_owned());
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::&lt;Rc&lt;String&gt;, String&gt;::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="macro">assert_eq!</span>(cache.get_or_insert_ref(<span class="kw-2">&amp;</span>key1, ||<span class="string">"One"</span>.to_owned()), <span class="string">"One"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert_ref(<span class="kw-2">&amp;</span>key2, ||<span class="string">"Two"</span>.to_owned()), <span class="string">"Two"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert_ref(<span class="kw-2">&amp;</span>key2, ||<span class="string">"Not two"</span>.to_owned()), <span class="string">"Two"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert_ref(<span class="kw-2">&amp;</span>key2, ||<span class="string">"Again not two"</span>.to_owned()), <span class="string">"Two"</span>);
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key1), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key2), <span class="number">2</span>); <span class="comment">// key2 was only cloned once even though we
                                        // queried it 3 times</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_get_or_insert" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#692-714">Source</a><h4 class="code-header">pub fn <a href="#method.try_get_or_insert" class="fn">try_get_or_insert</a>&lt;F, E&gt;(&amp;mut self, k: K, f: F) -&gt; Result&lt;&amp;V, E&gt;<div class="where">where
    F: FnOnce() -&gt; Result&lt;V, E&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a reference is returned. If <code>FnOnce</code> returns <code>Err</code>,
returns the <code>Err</code>.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">2</span>, <span class="string">"c"</span>);
cache.put(<span class="number">3</span>, <span class="string">"d"</span>);

<span class="kw">let </span>f = ||-&gt;<span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span>str, String&gt; {<span class="prelude-val">Err</span>(<span class="string">"failed"</span>.to_owned())};
<span class="kw">let </span>a = ||-&gt;<span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span>str, String&gt; {<span class="prelude-val">Ok</span>(<span class="string">"a"</span>)};
<span class="kw">let </span>b = ||-&gt;<span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span>str, String&gt; {<span class="prelude-val">Ok</span>(<span class="string">"b"</span>)};
<span class="macro">assert_eq!</span>(cache.try_get_or_insert(<span class="number">2</span>, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"c"</span>));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert(<span class="number">3</span>, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"d"</span>));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert(<span class="number">4</span>, f), <span class="prelude-val">Err</span>(<span class="string">"failed"</span>.to_owned()));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert(<span class="number">5</span>, b), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"b"</span>));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert(<span class="number">5</span>, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"b"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_get_or_insert_ref" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#745-769">Source</a><h4 class="code-header">pub fn <a href="#method.try_get_or_insert_ref" class="fn">try_get_or_insert_ref</a>&lt;'a, Q, F, E&gt;(
    &amp;'a mut self,
    k: &amp;Q,
    f: F,
) -&gt; Result&lt;&amp;'a V, E&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized + ToOwned&lt;Owned = K&gt;,
    F: FnOnce() -&gt; Result&lt;V, E&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a reference is returned. If <code>FnOnce</code> returns <code>Err</code>,
returns the <code>Err</code>. The value referenced by the key is only cloned
(using <code>to_owned()</code>) if it doesn’t exist in the cache and <code>FnOnce</code>
succeeds.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">use </span>std::rc::Rc;

<span class="kw">let </span>key1 = Rc::new(<span class="string">"1"</span>.to_owned());
<span class="kw">let </span>key2 = Rc::new(<span class="string">"2"</span>.to_owned());
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::&lt;Rc&lt;String&gt;, String&gt;::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="kw">let </span>f = ||-&gt;<span class="prelude-ty">Result</span>&lt;String, ()&gt; {<span class="prelude-val">Err</span>(())};
<span class="kw">let </span>a = ||-&gt;<span class="prelude-ty">Result</span>&lt;String, ()&gt; {<span class="prelude-val">Ok</span>(<span class="string">"One"</span>.to_owned())};
<span class="kw">let </span>b = ||-&gt;<span class="prelude-ty">Result</span>&lt;String, ()&gt; {<span class="prelude-val">Ok</span>(<span class="string">"Two"</span>.to_owned())};
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_ref(<span class="kw-2">&amp;</span>key1, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"One"</span>.to_owned()));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_ref(<span class="kw-2">&amp;</span>key2, f), <span class="prelude-val">Err</span>(()));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_ref(<span class="kw-2">&amp;</span>key2, b), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"Two"</span>.to_owned()));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_ref(<span class="kw-2">&amp;</span>key2, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;</span><span class="string">"Two"</span>.to_owned()));
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key1), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key2), <span class="number">2</span>); <span class="comment">// key2 was only cloned once even though we
                                        // queried it 3 times</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_or_insert_mut" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#793-815">Source</a><h4 class="code-header">pub fn <a href="#method.get_or_insert_mut" class="fn">get_or_insert_mut</a>&lt;F&gt;(&amp;mut self, k: K, f: F) -&gt; &amp;mut V<div class="where">where
    F: FnOnce() -&gt; V,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a mutable reference is returned.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);

<span class="kw">let </span>v = cache.get_or_insert_mut(<span class="number">2</span>, ||<span class="string">"c"</span>);
<span class="macro">assert_eq!</span>(v, <span class="kw-2">&amp;</span><span class="string">"b"</span>);
<span class="kw-2">*</span>v = <span class="string">"d"</span>;
<span class="macro">assert_eq!</span>(cache.get_or_insert_mut(<span class="number">2</span>, ||<span class="string">"e"</span>), <span class="kw-2">&amp;mut </span><span class="string">"d"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert_mut(<span class="number">3</span>, ||<span class="string">"f"</span>), <span class="kw-2">&amp;mut </span><span class="string">"f"</span>);
<span class="macro">assert_eq!</span>(cache.get_or_insert_mut(<span class="number">3</span>, ||<span class="string">"e"</span>), <span class="kw-2">&amp;mut </span><span class="string">"f"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_or_insert_mut_ref" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#841-865">Source</a><h4 class="code-header">pub fn <a href="#method.get_or_insert_mut_ref" class="fn">get_or_insert_mut_ref</a>&lt;'a, Q, F&gt;(&amp;mut self, k: &amp;Q, f: F) -&gt; &amp;'a mut V<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized + ToOwned&lt;Owned = K&gt;,
    F: FnOnce() -&gt; V,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a mutable reference is returned. The value referenced by the
key is only cloned (using <code>to_owned()</code>) if it doesn’t exist in the cache.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">use </span>std::rc::Rc;

<span class="kw">let </span>key1 = Rc::new(<span class="string">"1"</span>.to_owned());
<span class="kw">let </span>key2 = Rc::new(<span class="string">"2"</span>.to_owned());
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::&lt;Rc&lt;String&gt;, <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str&gt;::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
cache.get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key1, ||<span class="string">"One"</span>);
<span class="kw">let </span>v = cache.get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key2, ||<span class="string">"Two"</span>);
<span class="kw-2">*</span>v = <span class="string">"New two"</span>;
<span class="macro">assert_eq!</span>(cache.get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key2, ||<span class="string">"Two"</span>), <span class="kw-2">&amp;mut </span><span class="string">"New two"</span>);
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key1), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key2), <span class="number">2</span>); <span class="comment">// key2 was only cloned once even though we
                                        // queried it 2 times</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_get_or_insert_mut" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#895-917">Source</a><h4 class="code-header">pub fn <a href="#method.try_get_or_insert_mut" class="fn">try_get_or_insert_mut</a>&lt;F, E&gt;(&amp;mut self, k: K, f: F) -&gt; Result&lt;&amp;mut V, E&gt;<div class="where">where
    F: FnOnce() -&gt; Result&lt;V, E&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a mutable reference is returned. If <code>FnOnce</code> returns <code>Err</code>,
returns the <code>Err</code>.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">2</span>, <span class="string">"c"</span>);

<span class="kw">let </span>f = ||-&gt;<span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span>str, String&gt; {<span class="prelude-val">Err</span>(<span class="string">"failed"</span>.to_owned())};
<span class="kw">let </span>a = ||-&gt;<span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span>str, String&gt; {<span class="prelude-val">Ok</span>(<span class="string">"a"</span>)};
<span class="kw">let </span>b = ||-&gt;<span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;</span>str, String&gt; {<span class="prelude-val">Ok</span>(<span class="string">"b"</span>)};
<span class="kw">if let </span><span class="prelude-val">Ok</span>(v) = cache.try_get_or_insert_mut(<span class="number">2</span>, a) {
    <span class="kw-2">*</span>v = <span class="string">"d"</span>;
}
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut(<span class="number">2</span>, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="string">"d"</span>));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut(<span class="number">3</span>, f), <span class="prelude-val">Err</span>(<span class="string">"failed"</span>.to_owned()));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut(<span class="number">4</span>, b), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="string">"b"</span>));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut(<span class="number">4</span>, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="string">"b"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_get_or_insert_mut_ref" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#950-978">Source</a><h4 class="code-header">pub fn <a href="#method.try_get_or_insert_mut_ref" class="fn">try_get_or_insert_mut_ref</a>&lt;'a, Q, F, E&gt;(
    &amp;'a mut self,
    k: &amp;Q,
    f: F,
) -&gt; Result&lt;&amp;'a mut V, E&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized + ToOwned&lt;Owned = K&gt;,
    F: FnOnce() -&gt; Result&lt;V, E&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value of the key in the cache if it is
present in the cache and moves the key to the head of the LRU list.
If the key does not exist the provided <code>FnOnce</code> is used to populate
the list and a mutable reference is returned. If <code>FnOnce</code> returns <code>Err</code>,
returns the <code>Err</code>. The value referenced by the key is only cloned
(using <code>to_owned()</code>) if it doesn’t exist in the cache and <code>FnOnce</code>
succeeds.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">use </span>std::rc::Rc;

<span class="kw">let </span>key1 = Rc::new(<span class="string">"1"</span>.to_owned());
<span class="kw">let </span>key2 = Rc::new(<span class="string">"2"</span>.to_owned());
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::&lt;Rc&lt;String&gt;, String&gt;::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="kw">let </span>f = ||-&gt;<span class="prelude-ty">Result</span>&lt;String, ()&gt; {<span class="prelude-val">Err</span>(())};
<span class="kw">let </span>a = ||-&gt;<span class="prelude-ty">Result</span>&lt;String, ()&gt; {<span class="prelude-val">Ok</span>(<span class="string">"One"</span>.to_owned())};
<span class="kw">let </span>b = ||-&gt;<span class="prelude-ty">Result</span>&lt;String, ()&gt; {<span class="prelude-val">Ok</span>(<span class="string">"Two"</span>.to_owned())};
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key1, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="string">"One"</span>.to_owned()));
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key2, f), <span class="prelude-val">Err</span>(()));
<span class="kw">if let </span><span class="prelude-val">Ok</span>(v) = cache.try_get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key2, b) {
    <span class="kw-2">*</span>v = <span class="string">"New two"</span>.to_owned();
}
<span class="macro">assert_eq!</span>(cache.try_get_or_insert_mut_ref(<span class="kw-2">&amp;</span>key2, a), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="string">"New two"</span>.to_owned()));
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key1), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(Rc::strong_count(<span class="kw-2">&amp;</span>key2), <span class="number">2</span>); <span class="comment">// key2 was only cloned once even though we
                                        // queried it 3 times</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#997-1005">Source</a><h4 class="code-header">pub fn <a href="#method.peek" class="fn">peek</a>&lt;'a, Q&gt;(&amp;'a self, k: &amp;Q) -&gt; Option&lt;&amp;'a V&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a reference to the value corresponding to the key in the cache or <code>None</code> if it is
not present in the cache. Unlike <code>get</code>, <code>peek</code> does not update the LRU list so the key’s
position will be unchanged.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);

<span class="macro">assert_eq!</span>(cache.peek(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(cache.peek(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"b"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_mut" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1024-1033">Source</a><h4 class="code-header">pub fn <a href="#method.peek_mut" class="fn">peek_mut</a>&lt;'a, Q&gt;(&amp;'a mut self, k: &amp;Q) -&gt; Option&lt;&amp;'a mut V&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value corresponding to the key in the cache or <code>None</code>
if it is not present in the cache. Unlike <code>get_mut</code>, <code>peek_mut</code> does not update the LRU
list so the key’s position will be unchanged.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);

<span class="macro">assert_eq!</span>(cache.peek_mut(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(cache.peek_mut(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="string">"b"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_lru" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1051-1064">Source</a><h4 class="code-header">pub fn <a href="#method.peek_lru" class="fn">peek_lru</a>(&amp;self) -&gt; Option&lt;(&amp;K, &amp;V)&gt;</h4></section></summary><div class="docblock"><p>Returns the value corresponding to the least recently used item or <code>None</code> if the
cache is empty. Like <code>peek</code>, <code>peek_lru</code> does not update the LRU list so the item’s
position will be unchanged.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);

<span class="macro">assert_eq!</span>(cache.peek_lru(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="string">"a"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_mru" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1082-1095">Source</a><h4 class="code-header">pub fn <a href="#method.peek_mru" class="fn">peek_mru</a>(&amp;self) -&gt; Option&lt;(&amp;K, &amp;V)&gt;</h4></section></summary><div class="docblock"><p>Returns the value corresponding to the most recently used item or <code>None</code> if the
cache is empty. Like <code>peek</code>, <code>peek_mru</code> does not update the LRU list so the item’s
position will be unchanged.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);

<span class="macro">assert_eq!</span>(cache.peek_mru(), <span class="prelude-val">Some</span>((<span class="kw-2">&amp;</span><span class="number">2</span>, <span class="kw-2">&amp;</span><span class="string">"b"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1115-1121">Source</a><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;Q&gt;(&amp;self, k: &amp;Q) -&gt; bool<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Returns a bool indicating whether the given key is in the cache. Does not update the
LRU list.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">3</span>, <span class="string">"c"</span>);

<span class="macro">assert!</span>(!cache.contains(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert!</span>(cache.contains(<span class="kw-2">&amp;</span><span class="number">2</span>));
<span class="macro">assert!</span>(cache.contains(<span class="kw-2">&amp;</span><span class="number">3</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1140-1161">Source</a><h4 class="code-header">pub fn <a href="#method.pop" class="fn">pop</a>&lt;Q&gt;(&amp;mut self, k: &amp;Q) -&gt; Option&lt;V&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Removes and returns the value corresponding to the key from the cache or
<code>None</code> if it does not exist.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">2</span>, <span class="string">"a"</span>);

<span class="macro">assert_eq!</span>(cache.pop(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.pop(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(cache.pop(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_entry" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1182-1198">Source</a><h4 class="code-header">pub fn <a href="#method.pop_entry" class="fn">pop_entry</a>&lt;Q&gt;(&amp;mut self, k: &amp;Q) -&gt; Option&lt;(K, V)&gt;<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Removes and returns the key and the value corresponding to the key from the cache or
<code>None</code> if it does not exist.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"a"</span>);

<span class="macro">assert_eq!</span>(cache.pop(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(cache.pop_entry(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">"a"</span>)));
<span class="macro">assert_eq!</span>(cache.pop(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.pop_entry(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_lru" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1220-1226">Source</a><h4 class="code-header">pub fn <a href="#method.pop_lru" class="fn">pop_lru</a>(&amp;mut self) -&gt; Option&lt;(K, V)&gt;</h4></section></summary><div class="docblock"><p>Removes and returns the key and value corresponding to the least recently
used item or <code>None</code> if the cache is empty.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">2</span>, <span class="string">"a"</span>);
cache.put(<span class="number">3</span>, <span class="string">"b"</span>);
cache.put(<span class="number">4</span>, <span class="string">"c"</span>);
cache.get(<span class="kw-2">&amp;</span><span class="number">3</span>);

<span class="macro">assert_eq!</span>(cache.pop_lru(), <span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">"c"</span>)));
<span class="macro">assert_eq!</span>(cache.pop_lru(), <span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">"b"</span>)));
<span class="macro">assert_eq!</span>(cache.pop_lru(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_mru" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1248-1254">Source</a><h4 class="code-header">pub fn <a href="#method.pop_mru" class="fn">pop_mru</a>(&amp;mut self) -&gt; Option&lt;(K, V)&gt;</h4></section></summary><div class="docblock"><p>Removes and returns the key and value corresponding to the most recently
used item or <code>None</code> if the cache is empty.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">2</span>, <span class="string">"a"</span>);
cache.put(<span class="number">3</span>, <span class="string">"b"</span>);
cache.put(<span class="number">4</span>, <span class="string">"c"</span>);
cache.get(<span class="kw-2">&amp;</span><span class="number">3</span>);

<span class="macro">assert_eq!</span>(cache.pop_mru(), <span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">"b"</span>)));
<span class="macro">assert_eq!</span>(cache.pop_mru(), <span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">"c"</span>)));
<span class="macro">assert_eq!</span>(cache.pop_mru(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.promote" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1278-1288">Source</a><h4 class="code-header">pub fn <a href="#method.promote" class="fn">promote</a>&lt;Q&gt;(&amp;mut self, k: &amp;Q)<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Marks the key as the most recently used one.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">3</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">3</span>, <span class="string">"c"</span>);
cache.get(<span class="kw-2">&amp;</span><span class="number">1</span>);
cache.get(<span class="kw-2">&amp;</span><span class="number">2</span>);

<span class="comment">// If we do `pop_lru` now, we would pop 3.
// assert_eq!(cache.pop_lru(), Some((3, "c")));

// By promoting 3, we make sure it isn't popped.
</span>cache.promote(<span class="kw-2">&amp;</span><span class="number">3</span>);
<span class="macro">assert_eq!</span>(cache.pop_lru(), <span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">"a"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.demote" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1314-1324">Source</a><h4 class="code-header">pub fn <a href="#method.demote" class="fn">demote</a>&lt;Q&gt;(&amp;mut self, k: &amp;Q)<div class="where">where
    K: Borrow&lt;Q&gt;,
    Q: Hash + Eq + ?Sized,</div></h4></section></summary><div class="docblock"><p>Marks the key as the least recently used one.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">3</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.put(<span class="number">3</span>, <span class="string">"c"</span>);
cache.get(<span class="kw-2">&amp;</span><span class="number">1</span>);
cache.get(<span class="kw-2">&amp;</span><span class="number">2</span>);

<span class="comment">// If we do `pop_lru` now, we would pop 3.
// assert_eq!(cache.pop_lru(), Some((3, "c")));

// By demoting 1 and 2, we make sure those are popped first.
</span>cache.demote(<span class="kw-2">&amp;</span><span class="number">2</span>);
cache.demote(<span class="kw-2">&amp;</span><span class="number">1</span>);
<span class="macro">assert_eq!</span>(cache.pop_lru(), <span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">"a"</span>)));
<span class="macro">assert_eq!</span>(cache.pop_lru(), <span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">"b"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1345-1347">Source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the number of key-value pairs that are currently in the the cache.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">1</span>);

cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">2</span>);

cache.put(<span class="number">3</span>, <span class="string">"c"</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1362-1364">Source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>Returns a bool indicating whether the cache is empty or not.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="macro">assert!</span>(cache.is_empty());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert!</span>(!cache.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cap" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1376-1378">Source</a><h4 class="code-header">pub fn <a href="#method.cap" class="fn">cap</a>(&amp;self) -&gt; NonZeroUsize</h4></section></summary><div class="docblock"><p>Returns the maximum number of key-value pairs the cache can hold.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="macro">assert_eq!</span>(cache.cap().get(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resize" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1402-1414">Source</a><h4 class="code-header">pub fn <a href="#method.resize" class="fn">resize</a>(&amp;mut self, cap: NonZeroUsize)</h4></section></summary><div class="docblock"><p>Resizes the cache. If the new capacity is smaller than the size of the current
cache any entries past the new capacity are discarded.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
cache.resize(NonZeroUsize::new(<span class="number">4</span>).unwrap());
cache.put(<span class="number">3</span>, <span class="string">"c"</span>);
cache.put(<span class="number">4</span>, <span class="string">"d"</span>);

<span class="macro">assert_eq!</span>(cache.len(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"a"</span>));
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"b"</span>));
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"c"</span>));
<span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span><span class="number">4</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"d"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1435-1437">Source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears the contents of the cache.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;
<span class="kw">let </span><span class="kw-2">mut </span>cache: LruCache&lt;isize, <span class="kw-2">&amp;</span>str&gt; = LruCache::new(NonZeroUsize::new(<span class="number">2</span>).unwrap());
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);

cache.put(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">1</span>);

cache.put(<span class="number">2</span>, <span class="string">"b"</span>);
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">2</span>);

cache.clear();
<span class="macro">assert_eq!</span>(cache.len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1457-1464">Source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct lru::Iter">Iter</a>&lt;'_, K, V&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;_, K, V&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator visiting all entries in most-recently used order. The iterator element type is
<code>(&amp;K, &amp;V)</code>.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;

<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">3</span>).unwrap());
cache.put(<span class="string">"a"</span>, <span class="number">1</span>);
cache.put(<span class="string">"b"</span>, <span class="number">2</span>);
cache.put(<span class="string">"c"</span>, <span class="number">3</span>);

<span class="kw">for </span>(key, val) <span class="kw">in </span>cache.iter() {
    <span class="macro">println!</span>(<span class="string">"key: {} val: {}"</span>, key, val);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_mut" class="method"><a class="src rightside" href="../src/lru/lib.rs.html#1493-1500">Source</a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fn">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.IterMut.html" title="struct lru::IterMut">IterMut</a>&lt;'_, K, V&gt; <a href="#" class="tooltip" data-notable-ty="IterMut&lt;&#39;_, K, V&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator visiting all entries in most-recently-used order, giving a mutable reference on
V.  The iterator element type is <code>(&amp;K, &amp;mut V)</code>.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lru::LruCache;
<span class="kw">use </span>std::num::NonZeroUsize;

<span class="kw">struct </span>HddBlock {
    dirty: bool,
    data: [u8; <span class="number">512</span>]
}

<span class="kw">let </span><span class="kw-2">mut </span>cache = LruCache::new(NonZeroUsize::new(<span class="number">3</span>).unwrap());
cache.put(<span class="number">0</span>, HddBlock { dirty: <span class="bool-val">false</span>, data: [<span class="number">0x00</span>; <span class="number">512</span>]});
cache.put(<span class="number">1</span>, HddBlock { dirty: <span class="bool-val">true</span>,  data: [<span class="number">0x55</span>; <span class="number">512</span>]});
cache.put(<span class="number">2</span>, HddBlock { dirty: <span class="bool-val">true</span>,  data: [<span class="number">0x77</span>; <span class="number">512</span>]});

<span class="comment">// write dirty blocks to disk.
</span><span class="kw">for </span>(block_id, block) <span class="kw">in </span>cache.iter_mut() {
    <span class="kw">if </span>block.dirty {
        <span class="comment">// write block to disk
        </span>block.dirty = <span class="bool-val">false
    </span>}
}</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-LruCache%3CK,+V%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#196-210">Source</a><a href="#impl-Clone-for-LruCache%3CK,+V%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V&gt; Clone for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V&gt;<div class="where">where
    K: Hash + PartialEq + Eq + Clone,
    V: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#201-209">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a copy of the value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1601-1608">Source</a><a href="#impl-Debug-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Hash + Eq, V, S: BuildHasher&gt; Debug for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1602-1607">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1562-1575">Source</a><a href="#impl-Drop-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, S&gt; Drop for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1563-1574">Source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1577-1584">Source</a><a href="#impl-IntoIterator-for-%26LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: Hash + Eq, V, S: BuildHasher&gt; IntoIterator for &amp;'a <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1578">Source</a><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Item</a> = (&amp;'a K, &amp;'a V)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1579">Source</a><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct lru::Iter">Iter</a>&lt;'a, K, V&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1581-1583">Source</a><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into_iter</a>(self) -&gt; <a class="struct" href="struct.Iter.html" title="struct lru::Iter">Iter</a>&lt;'a, K, V&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;a, K, V&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26mut+LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1586-1593">Source</a><a href="#impl-IntoIterator-for-%26mut+LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K: Hash + Eq, V, S: BuildHasher&gt; IntoIterator for &amp;'a mut <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1587">Source</a><a href="#associatedtype.Item-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Item</a> = (&amp;'a K, &amp;'a mut V)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1588">Source</a><a href="#associatedtype.IntoIter-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IterMut.html" title="struct lru::IterMut">IterMut</a>&lt;'a, K, V&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1590-1592">Source</a><a href="#method.into_iter-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into_iter</a>(self) -&gt; <a class="struct" href="struct.IterMut.html" title="struct lru::IterMut">IterMut</a>&lt;'a, K, V&gt; <a href="#" class="tooltip" data-notable-ty="IterMut&lt;&#39;a, K, V&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-LruCache%3CK,+V%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1790-1797">Source</a><a href="#impl-IntoIterator-for-LruCache%3CK,+V%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Hash + Eq, V&gt; IntoIterator for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1791">Source</a><a href="#associatedtype.Item-2" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Item</a> = (K, V)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1792">Source</a><a href="#associatedtype.IntoIter-2" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct lru::IntoIter">IntoIter</a>&lt;K, V&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-2" class="method trait-impl"><a class="src rightside" href="../src/lru/lib.rs.html#1794-1796">Source</a><a href="#method.into_iter-2" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into_iter</a>(self) -&gt; <a class="struct" href="struct.IntoIter.html" title="struct lru::IntoIter">IntoIter</a>&lt;K, V&gt; <a href="#" class="tooltip" data-notable-ty="IntoIter&lt;K, V&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a>Read more</a></div></details></div></details><section id="impl-Send-for-LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1598">Source</a><a href="#impl-Send-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Send, V: Send, S: Send&gt; Send for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section><section id="impl-Sync-for-LruCache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../src/lru/lib.rs.html#1599">Source</a><a href="#impl-Sync-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Sync, V: Sync, S: Sync&gt; Sync for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-LruCache%3CK,+V,+S%3E" class="impl"><a href="#impl-Freeze-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, S&gt; Freeze for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;<div class="where">where
    S: Freeze,</div></h3></section><section id="impl-RefUnwindSafe-for-LruCache%3CK,+V,+S%3E" class="impl"><a href="#impl-RefUnwindSafe-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, S&gt; RefUnwindSafe for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;<div class="where">where
    S: RefUnwindSafe,
    K: RefUnwindSafe,
    V: RefUnwindSafe,</div></h3></section><section id="impl-Unpin-for-LruCache%3CK,+V,+S%3E" class="impl"><a href="#impl-Unpin-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, S&gt; Unpin for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;<div class="where">where
    S: Unpin,</div></h3></section><section id="impl-UnwindSafe-for-LruCache%3CK,+V,+S%3E" class="impl"><a href="#impl-UnwindSafe-for-LruCache%3CK,+V,+S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K, V, S&gt; UnwindSafe for <a class="struct" href="struct.LruCache.html" title="struct lru::LruCache">LruCache</a>&lt;K, V, S&gt;<div class="where">where
    S: UnwindSafe,
    K: RefUnwindSafe,
    V: RefUnwindSafe,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneToUninit for T<div class="where">where
    T: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">clone_to_uninit</a>(&amp;self, dest: *mut u8)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ToOwned for T<div class="where">where
    T: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone_into</a>(&amp;self, target: &amp;mut T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"IntoIter<K, V>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct lru::IntoIter\">IntoIter</a>&lt;K, V&gt;</code></h3><pre><code><div class=\"where\">impl&lt;K, V&gt; Iterator for <a class=\"struct\" href=\"struct.IntoIter.html\" title=\"struct lru::IntoIter\">IntoIter</a>&lt;K, V&gt;<div class=\"where\">where\n    K: Hash + Eq,</div></div><div class=\"where\">    type <a class=\"associatedtype\">Item</a> = (K, V);</div>","Iter<'_, K, V>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct lru::Iter\">Iter</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, K, V&gt; Iterator for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct lru::Iter\">Iter</a>&lt;'a, K, V&gt;</div><div class=\"where\">    type <a class=\"associatedtype\">Item</a> = (&amp;'a K, &amp;'a V);</div>","Iter<'a, K, V>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct lru::Iter\">Iter</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, K, V&gt; Iterator for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct lru::Iter\">Iter</a>&lt;'a, K, V&gt;</div><div class=\"where\">    type <a class=\"associatedtype\">Item</a> = (&amp;'a K, &amp;'a V);</div>","IterMut<'_, K, V>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct lru::IterMut\">IterMut</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, K, V&gt; Iterator for <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct lru::IterMut\">IterMut</a>&lt;'a, K, V&gt;</div><div class=\"where\">    type <a class=\"associatedtype\">Item</a> = (&amp;'a K, &amp;'a mut V);</div>","IterMut<'a, K, V>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct lru::IterMut\">IterMut</a>&lt;'a, K, V&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, K, V&gt; Iterator for <a class=\"struct\" href=\"struct.IterMut.html\" title=\"struct lru::IterMut\">IterMut</a>&lt;'a, K, V&gt;</div><div class=\"where\">    type <a class=\"associatedtype\">Item</a> = (&amp;'a K, &amp;'a mut V);</div>"}</script></section></div></main></body></html>