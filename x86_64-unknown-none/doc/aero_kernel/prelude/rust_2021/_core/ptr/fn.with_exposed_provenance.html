<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converts an address back to a pointer, picking up some previously ‘exposed’ provenance."><title>with_exposed_provenance in aero_kernel::prelude::rust_2021::_core::ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="aero_kernel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (d5b4c2e4f 2025-04-02)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-d72f25bb.js" ><script src="../../../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../aero_kernel/index.html">aero_<wbr>kernel</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In aero_<wbr>kernel::<wbr>prelude::<wbr>rust_<wbr>2021::<wbr>_<wbr>core::<wbr>ptr</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../../index.html">aero_kernel</a>::<wbr><a href="../../../index.html">prelude</a>::<wbr><a href="../../index.html">rust_2021</a>::<wbr><a href="../index.html">_core</a>::<wbr><a href="index.html">ptr</a></div><h1>Function <span class="fn">with_exposed_provenance</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span></span></div><pre class="rust item-decl"><code>pub fn with_exposed_provenance&lt;T&gt;(addr: usize) -&gt; *const T</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converts an address back to a pointer, picking up some previously ‘exposed’
<a href="index.html#provenance" title="mod aero_kernel::prelude::rust_2021::_core::ptr">provenance</a>.</p>
<p>This is fully equivalent to <code>addr as *const T</code>. The provenance of the returned pointer is that
of <em>some</em> pointer that was previously exposed by passing it to
[<code>expose_provenance</code>][pointer::expose_provenance], or a <code>ptr as usize</code> cast. In addition, memory
which is outside the control of the Rust abstract machine (MMIO registers, for example) is
always considered to be accessible with an exposed provenance, so long as this memory is disjoint
from memory that will be used by the abstract machine such as the stack, heap, and statics.</p>
<p>The exact provenance that gets picked is not specified. The compiler will do its best to pick
the “right” provenance for you (whatever that may be), but currently we cannot provide any
guarantees about which provenance the resulting pointer will have – and therefore there
is no definite specification for which memory the resulting pointer may access.</p>
<p>If there is <em>no</em> previously ‘exposed’ provenance that justifies the way the returned pointer
will be used, the program has undefined behavior. In particular, the aliasing rules still apply:
pointers and references that have been invalidated due to aliasing accesses cannot be used
anymore, even if they have been exposed!</p>
<p>Due to its inherent ambiguity, this operation may not be supported by tools that help you to
stay conformant with the Rust memory model. It is recommended to use <a href="index.html#strict-provenance" title="mod aero_kernel::prelude::rust_2021::_core::ptr">Strict
Provenance</a> APIs such as [<code>with_addr</code>][pointer::with_addr] wherever
possible.</p>
<p>On most platforms this will produce a value with the same bytes as the address. Platforms
which need to store additional information in a pointer may not support this operation,
since it is generally not possible to actually <em>compute</em> which provenance the returned
pointer has to pick up.</p>
<p>This is an <a href="index.html#exposed-provenance" title="mod aero_kernel::prelude::rust_2021::_core::ptr">Exposed Provenance</a> API.</p>
</div></details></section></div></main></body></html>