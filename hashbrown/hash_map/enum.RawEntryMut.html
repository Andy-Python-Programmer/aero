<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A view into a single entry in a map, which may either be vacant or occupied."><title>RawEntryMut in hashbrown::hash_map - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-4e54bb2b497cc83f.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hashbrown" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (595bc6f00 2024-01-05)" data-channel="nightly" data-search-js="search-c17e98913a53b3b7.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-0b2e2def73e61cbe.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hashbrown/index.html">hashbrown</a><span class="version">0.14.1</span></h2></div><h2 class="location"><a href="#">RawEntryMut</a></h2><div class="sidebar-elems"><section><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.Occupied">Occupied</a></li><li><a href="#variant.Vacant">Vacant</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.and_modify">and_modify</a></li><li><a href="#method.and_replace_entry_with">and_replace_entry_with</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.or_insert">or_insert</a></li><li><a href="#method.or_insert_with">or_insert_with</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-RawEntryMut%3C'_,+K,+V,+S,+A%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-UnwindSafe-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E">!UnwindSafe</a></li><li><a href="#impl-RefUnwindSafe-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E">Send</a></li><li><a href="#impl-Sync-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E">Sync</a></li><li><a href="#impl-Unpin-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In hashbrown::hash_map</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../hashbrown/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Enum <a href="../index.html">hashbrown</a>::<wbr><a href="index.html">hash_map</a>::<wbr><a class="enum" href="#">RawEntryMut</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/hashbrown/map.rs.html#2946-2975">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub enum RawEntryMut&lt;'a, K, V, S, A: <a class="trait" href="../../allocator_api2/stable/alloc/trait.Allocator.html" title="trait allocator_api2::stable::alloc::Allocator">Allocator</a> = <a class="struct" href="../../allocator_api2/stable/alloc/global/struct.Global.html" title="struct allocator_api2::stable::alloc::global::Global">Global</a>&gt; {
    Occupied(<a class="struct" href="struct.RawOccupiedEntryMut.html" title="struct hashbrown::hash_map::RawOccupiedEntryMut">RawOccupiedEntryMut</a>&lt;'a, K, V, S, A&gt;),
    Vacant(<a class="struct" href="struct.RawVacantEntryMut.html" title="struct hashbrown::hash_map::RawVacantEntryMut">RawVacantEntryMut</a>&lt;'a, K, V, S, A&gt;),
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A view into a single entry in a map, which may either be vacant or occupied.</p>
<p>This is a lower-level version of <a href="enum.Entry.html"><code>Entry</code></a>.</p>
<p>This <code>enum</code> is constructed through the <a href="struct.HashMap.html#method.raw_entry_mut"><code>raw_entry_mut</code></a> method on <a href="struct.HashMap.html"><code>HashMap</code></a>,
then calling one of the methods of that <a href="struct.RawEntryBuilderMut.html"><code>RawEntryBuilderMut</code></a>.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::hash::{BuildHasher, Hash};
<span class="kw">use </span>hashbrown::hash_map::{HashMap, RawEntryMut, RawOccupiedEntryMut};

<span class="kw">let </span><span class="kw-2">mut </span>map = HashMap::new();
map.extend([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)]);
<span class="macro">assert_eq!</span>(map.len(), <span class="number">3</span>);

<span class="kw">fn </span>compute_hash&lt;K: Hash + <span class="question-mark">?</span>Sized, S: BuildHasher&gt;(hash_builder: <span class="kw-2">&amp;</span>S, key: <span class="kw-2">&amp;</span>K) -&gt; u64 {
    <span class="kw">use </span>core::hash::Hasher;
    <span class="kw">let </span><span class="kw-2">mut </span>state = hash_builder.build_hasher();
    key.hash(<span class="kw-2">&amp;mut </span>state);
    state.finish()
}

<span class="comment">// Existing key (insert)
</span><span class="kw">let </span>raw: RawEntryMut&lt;<span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>&gt; = map.raw_entry_mut().from_key(<span class="kw-2">&amp;</span><span class="string">'a'</span>);
<span class="kw">let </span>_raw_o: RawOccupiedEntryMut&lt;<span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>&gt; = raw.insert(<span class="string">'a'</span>, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(map.len(), <span class="number">3</span>);

<span class="comment">// Nonexistent key (insert)
</span>map.raw_entry_mut().from_key(<span class="kw-2">&amp;</span><span class="string">'d'</span>).insert(<span class="string">'d'</span>, <span class="number">40</span>);
<span class="macro">assert_eq!</span>(map.len(), <span class="number">4</span>);

<span class="comment">// Existing key (or_insert)
</span><span class="kw">let </span>hash = compute_hash(map.hasher(), <span class="kw-2">&amp;</span><span class="string">'b'</span>);
<span class="kw">let </span>kv = map
    .raw_entry_mut()
    .from_key_hashed_nocheck(hash, <span class="kw-2">&amp;</span><span class="string">'b'</span>)
    .or_insert(<span class="string">'b'</span>, <span class="number">20</span>);
<span class="macro">assert_eq!</span>(kv, (<span class="kw-2">&amp;mut </span><span class="string">'b'</span>, <span class="kw-2">&amp;mut </span><span class="number">2</span>));
<span class="kw-2">*</span>kv.<span class="number">1 </span>= <span class="number">20</span>;
<span class="macro">assert_eq!</span>(map.len(), <span class="number">4</span>);

<span class="comment">// Nonexistent key (or_insert)
</span><span class="kw">let </span>hash = compute_hash(map.hasher(), <span class="kw-2">&amp;</span><span class="string">'e'</span>);
<span class="kw">let </span>kv = map
    .raw_entry_mut()
    .from_key_hashed_nocheck(hash, <span class="kw-2">&amp;</span><span class="string">'e'</span>)
    .or_insert(<span class="string">'e'</span>, <span class="number">50</span>);
<span class="macro">assert_eq!</span>(kv, (<span class="kw-2">&amp;mut </span><span class="string">'e'</span>, <span class="kw-2">&amp;mut </span><span class="number">50</span>));
<span class="macro">assert_eq!</span>(map.len(), <span class="number">5</span>);

<span class="comment">// Existing key (or_insert_with)
</span><span class="kw">let </span>hash = compute_hash(map.hasher(), <span class="kw-2">&amp;</span><span class="string">'c'</span>);
<span class="kw">let </span>kv = map
    .raw_entry_mut()
    .from_hash(hash, |q| q == <span class="kw-2">&amp;</span><span class="string">'c'</span>)
    .or_insert_with(|| (<span class="string">'c'</span>, <span class="number">30</span>));
<span class="macro">assert_eq!</span>(kv, (<span class="kw-2">&amp;mut </span><span class="string">'c'</span>, <span class="kw-2">&amp;mut </span><span class="number">3</span>));
<span class="kw-2">*</span>kv.<span class="number">1 </span>= <span class="number">30</span>;
<span class="macro">assert_eq!</span>(map.len(), <span class="number">5</span>);

<span class="comment">// Nonexistent key (or_insert_with)
</span><span class="kw">let </span>hash = compute_hash(map.hasher(), <span class="kw-2">&amp;</span><span class="string">'f'</span>);
<span class="kw">let </span>kv = map
    .raw_entry_mut()
    .from_hash(hash, |q| q == <span class="kw-2">&amp;</span><span class="string">'f'</span>)
    .or_insert_with(|| (<span class="string">'f'</span>, <span class="number">60</span>));
<span class="macro">assert_eq!</span>(kv, (<span class="kw-2">&amp;mut </span><span class="string">'f'</span>, <span class="kw-2">&amp;mut </span><span class="number">60</span>));
<span class="macro">assert_eq!</span>(map.len(), <span class="number">6</span>);

<span class="macro">println!</span>(<span class="string">"Our HashMap: {:?}"</span>, map);

<span class="kw">let </span><span class="kw-2">mut </span>vec: Vec&lt;<span class="kw">_</span>&gt; = map.iter().map(|(<span class="kw-2">&amp;</span>k, <span class="kw-2">&amp;</span>v)| (k, v)).collect();
<span class="comment">// The `Iter` iterator produces items in arbitrary order, so the
// items must be sorted to test them against a sorted array.
</span>vec.sort_unstable();
<span class="macro">assert_eq!</span>(vec, [(<span class="string">'a'</span>, <span class="number">10</span>), (<span class="string">'b'</span>, <span class="number">20</span>), (<span class="string">'c'</span>, <span class="number">30</span>), (<span class="string">'d'</span>, <span class="number">40</span>), (<span class="string">'e'</span>, <span class="number">50</span>), (<span class="string">'f'</span>, <span class="number">60</span>)]);</code></pre></div>
</div></details><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.Occupied" class="variant"><a href="#variant.Occupied" class="anchor">§</a><h3 class="code-header">Occupied(<a class="struct" href="struct.RawOccupiedEntryMut.html" title="struct hashbrown::hash_map::RawOccupiedEntryMut">RawOccupiedEntryMut</a>&lt;'a, K, V, S, A&gt;)</h3></section><div class="docblock"><p>An occupied entry.</p>
<h4 id="examples-1"><a href="#examples-1">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::{hash_map::RawEntryMut, HashMap};
<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = [(<span class="string">"a"</span>, <span class="number">100</span>), (<span class="string">"b"</span>, <span class="number">200</span>)].into();

<span class="kw">match </span>map.raw_entry_mut().from_key(<span class="kw-2">&amp;</span><span class="string">"a"</span>) {
    RawEntryMut::Vacant(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
    RawEntryMut::Occupied(<span class="kw">_</span>) =&gt; { }
}</code></pre></div>
</div><section id="variant.Vacant" class="variant"><a href="#variant.Vacant" class="anchor">§</a><h3 class="code-header">Vacant(<a class="struct" href="struct.RawVacantEntryMut.html" title="struct hashbrown::hash_map::RawVacantEntryMut">RawVacantEntryMut</a>&lt;'a, K, V, S, A&gt;)</h3></section><div class="docblock"><p>A vacant entry.</p>
<h4 id="examples-2"><a href="#examples-2">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::{hash_map::RawEntryMut, HashMap};
<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw-2">&amp;</span>str, i32&gt; = HashMap::new();

<span class="kw">match </span>map.raw_entry_mut().from_key(<span class="string">"a"</span>) {
    RawEntryMut::Occupied(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
    RawEntryMut::Vacant(<span class="kw">_</span>) =&gt; { }
}</code></pre></div>
</div></div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="impl"><a class="src rightside" href="../../src/hashbrown/map.rs.html#3352-3544">source</a><a href="#impl-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, S, A: <a class="trait" href="../../allocator_api2/stable/alloc/trait.Allocator.html" title="trait allocator_api2::stable::alloc::Allocator">Allocator</a>&gt; <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'a, K, V, S, A&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><a class="src rightside" href="../../src/hashbrown/map.rs.html#3366-3378">source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>(self, key: K, value: V) -&gt; <a class="struct" href="struct.RawOccupiedEntryMut.html" title="struct hashbrown::hash_map::RawOccupiedEntryMut">RawOccupiedEntryMut</a>&lt;'a, K, V, S, A&gt;<div class="where">where
    K: Hash,
    S: BuildHasher,</div></h4></section></summary><div class="docblock"><p>Sets the value of the entry, and returns a RawOccupiedEntryMut.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::HashMap;

<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw-2">&amp;</span>str, u32&gt; = HashMap::new();
<span class="kw">let </span>entry = map.raw_entry_mut().from_key(<span class="string">"horseyland"</span>).insert(<span class="string">"horseyland"</span>, <span class="number">37</span>);

<span class="macro">assert_eq!</span>(entry.remove_entry(), (<span class="string">"horseyland"</span>, <span class="number">37</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.or_insert" class="method"><a class="src rightside" href="../../src/hashbrown/map.rs.html#3397-3406">source</a><h4 class="code-header">pub fn <a href="#method.or_insert" class="fn">or_insert</a>(self, default_key: K, default_val: V) -&gt; (&amp;'a mut K, &amp;'a mut V)<div class="where">where
    K: Hash,
    S: BuildHasher,</div></h4></section></summary><div class="docblock"><p>Ensures a value is in the entry by inserting the default if empty, and returns
mutable references to the key and value in the entry.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::HashMap;

<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw-2">&amp;</span>str, u32&gt; = HashMap::new();

map.raw_entry_mut().from_key(<span class="string">"poneyland"</span>).or_insert(<span class="string">"poneyland"</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(map[<span class="string">"poneyland"</span>], <span class="number">3</span>);

<span class="kw-2">*</span>map.raw_entry_mut().from_key(<span class="string">"poneyland"</span>).or_insert(<span class="string">"poneyland"</span>, <span class="number">10</span>).<span class="number">1 </span><span class="kw-2">*</span>= <span class="number">2</span>;
<span class="macro">assert_eq!</span>(map[<span class="string">"poneyland"</span>], <span class="number">6</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.or_insert_with" class="method"><a class="src rightside" href="../../src/hashbrown/map.rs.html#3425-3438">source</a><h4 class="code-header">pub fn <a href="#method.or_insert_with" class="fn">or_insert_with</a>&lt;F&gt;(self, default: F) -&gt; (&amp;'a mut K, &amp;'a mut V)<div class="where">where
    F: FnOnce() -&gt; (K, V),
    K: Hash,
    S: BuildHasher,</div></h4></section></summary><div class="docblock"><p>Ensures a value is in the entry by inserting the result of the default function if empty,
and returns mutable references to the key and value in the entry.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::HashMap;

<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw-2">&amp;</span>str, String&gt; = HashMap::new();

map.raw_entry_mut().from_key(<span class="string">"poneyland"</span>).or_insert_with(|| {
    (<span class="string">"poneyland"</span>, <span class="string">"hoho"</span>.to_string())
});

<span class="macro">assert_eq!</span>(map[<span class="string">"poneyland"</span>], <span class="string">"hoho"</span>.to_string());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.and_modify" class="method"><a class="src rightside" href="../../src/hashbrown/map.rs.html#3463-3477">source</a><h4 class="code-header">pub fn <a href="#method.and_modify" class="fn">and_modify</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: FnOnce(&amp;mut K, &amp;mut V),</div></h4></section></summary><div class="docblock"><p>Provides in-place mutable access to an occupied entry before any
potential inserts into the map.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::HashMap;

<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw-2">&amp;</span>str, u32&gt; = HashMap::new();

map.raw_entry_mut()
   .from_key(<span class="string">"poneyland"</span>)
   .and_modify(|_k, v| { <span class="kw-2">*</span>v += <span class="number">1 </span>})
   .or_insert(<span class="string">"poneyland"</span>, <span class="number">42</span>);
<span class="macro">assert_eq!</span>(map[<span class="string">"poneyland"</span>], <span class="number">42</span>);

map.raw_entry_mut()
   .from_key(<span class="string">"poneyland"</span>)
   .and_modify(|_k, v| { <span class="kw-2">*</span>v += <span class="number">1 </span>})
   .or_insert(<span class="string">"poneyland"</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(map[<span class="string">"poneyland"</span>], <span class="number">43</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.and_replace_entry_with" class="method"><a class="src rightside" href="../../src/hashbrown/map.rs.html#3535-3543">source</a><h4 class="code-header">pub fn <a href="#method.and_replace_entry_with" class="fn">and_replace_entry_with</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: FnOnce(&amp;K, V) -&gt; Option&lt;V&gt;,</div></h4></section></summary><div class="docblock"><p>Provides shared access to the key and owned access to the value of
an occupied entry and allows to replace or remove it based on the
value of the returned option.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::HashMap;
<span class="kw">use </span>hashbrown::hash_map::RawEntryMut;

<span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;<span class="kw-2">&amp;</span>str, u32&gt; = HashMap::new();

<span class="kw">let </span>entry = map
    .raw_entry_mut()
    .from_key(<span class="string">"poneyland"</span>)
    .and_replace_entry_with(|_k, _v| <span class="macro">panic!</span>());

<span class="kw">match </span>entry {
    RawEntryMut::Vacant(<span class="kw">_</span>) =&gt; {},
    RawEntryMut::Occupied(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(),
}

map.insert(<span class="string">"poneyland"</span>, <span class="number">42</span>);

<span class="kw">let </span>entry = map
    .raw_entry_mut()
    .from_key(<span class="string">"poneyland"</span>)
    .and_replace_entry_with(|k, v| {
        <span class="macro">assert_eq!</span>(k, <span class="kw-2">&amp;</span><span class="string">"poneyland"</span>);
        <span class="macro">assert_eq!</span>(v, <span class="number">42</span>);
        <span class="prelude-val">Some</span>(v + <span class="number">1</span>)
    });

<span class="kw">match </span>entry {
    RawEntryMut::Occupied(e) =&gt; {
        <span class="macro">assert_eq!</span>(e.key(), <span class="kw-2">&amp;</span><span class="string">"poneyland"</span>);
        <span class="macro">assert_eq!</span>(e.get(), <span class="kw-2">&amp;</span><span class="number">43</span>);
    },
    RawEntryMut::Vacant(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(),
}

<span class="macro">assert_eq!</span>(map[<span class="string">"poneyland"</span>], <span class="number">43</span>);

<span class="kw">let </span>entry = map
    .raw_entry_mut()
    .from_key(<span class="string">"poneyland"</span>)
    .and_replace_entry_with(|_k, _v| <span class="prelude-val">None</span>);

<span class="kw">match </span>entry {
    RawEntryMut::Vacant(<span class="kw">_</span>) =&gt; {},
    RawEntryMut::Occupied(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(),
}

<span class="macro">assert!</span>(!map.contains_key(<span class="string">"poneyland"</span>));</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-RawEntryMut%3C'_,+K,+V,+S,+A%3E" class="impl"><a class="src rightside" href="../../src/hashbrown/map.rs.html#4097-4104">source</a><a href="#impl-Debug-for-RawEntryMut%3C'_,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;K: Debug, V: Debug, S, A: <a class="trait" href="../../allocator_api2/stable/alloc/trait.Allocator.html" title="trait allocator_api2::stable::alloc::Allocator">Allocator</a>&gt; Debug for <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'_, K, V, S, A&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/hashbrown/map.rs.html#4098-4103">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="impl"><a href="#impl-RefUnwindSafe-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, S, A&gt; RefUnwindSafe for <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'a, K, V, S, A&gt;<div class="where">where
    A: RefUnwindSafe,
    K: RefUnwindSafe,
    S: RefUnwindSafe,
    V: RefUnwindSafe,</div></h3></section><section id="impl-Send-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="impl"><a href="#impl-Send-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, S, A&gt; Send for <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'a, K, V, S, A&gt;<div class="where">where
    A: Send,
    K: Send,
    S: Send + Sync,
    V: Send,</div></h3></section><section id="impl-Sync-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="impl"><a href="#impl-Sync-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, S, A&gt; Sync for <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'a, K, V, S, A&gt;<div class="where">where
    A: Sync,
    K: Sync,
    S: Sync,
    V: Sync,</div></h3></section><section id="impl-Unpin-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="impl"><a href="#impl-Unpin-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, S, A&gt; Unpin for <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'a, K, V, S, A&gt;</h3></section><section id="impl-UnwindSafe-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="impl"><a href="#impl-UnwindSafe-for-RawEntryMut%3C'a,+K,+V,+S,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, S, A = <a class="struct" href="../../allocator_api2/stable/alloc/global/struct.Global.html" title="struct allocator_api2::stable::alloc::global::Global">Global</a>&gt; !UnwindSafe for <a class="enum" href="enum.RawEntryMut.html" title="enum hashbrown::hash_map::RawEntryMut">RawEntryMut</a>&lt;'a, K, V, S, A&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>